{% extends "base.html" %}

{% block content %}
<div class="container-fluid px-2 py-2 content-container">
    <div id="stations"></div>
</div>

<!-- Calendar Modal -->
<div id="calendarModal" class="modal">
    <div class="modal-content">
        <span class="close">×</span>
        <div id="calendar"></div>
    </div>
</div>

<style>
        /* Prevent text selection for app like experience */
    *:not(input, textarea) {
        user-select: none; /* Prevent text selection */
        -webkit-user-select: none; /* For Safari */
        -moz-user-select: none; /* For Firefox */
        -ms-user-select: none; /* For IE10+/Edge */
    }

    /* General Styles */
    .content-container {
        max-width: 600px;
    }

    .station-card {
        background-color: #414141;
        border-radius: 8px;
        margin-bottom: 12px;
        box-shadow: 0 2px 4px rgba(0,0,0,0.1);
    }

    .station-header {
        padding: 8px 12px;
        border-bottom: 1px solid #555;
        background-color: #414141;
        border-radius: 8px 8px 0 0;
        color: white;
    }

    /* Base styles */
    .participants-list {
        perspective: 400px;
        background-color: #fff;
        border-radius: 0 0 8px 8px;
        padding: 4px;
    }

    .participant-item {
        border: none !important;
        margin: 2px 0;
        border-radius: 4px !important;
        font-size: 0.9rem;
        transform-style: preserve-3d;
        perspective: 1000px;
    }

    .participant-name {
        font-weight: bold;
    }

    /* Status colors */
    .participant-status-active {
        background-color: #d4edda;
    }

    .participant-status-inactive {
        background-color: #f8d7da;
    }

    .participant-status-disabled {
        background-color: #e9ecef;
    }

    /* Flip Animation */
    @keyframes cardFlip {
        0% { transform: rotateX(0); }
        100% { transform: rotateX(-360deg); }
    }

    .participant-item.status-changing {
        animation: cardFlip 1s ease-in-out;
        transform-style: preserve-3d;
        transform-origin: center;
        backface-visibility: hidden;
    }

    /* Smooth background transitions */
    .participant-status-active,
    .participant-status-inactive {
        transition: background-color 0.4s ease-in-out;
    }


    /* Calendar Styles */
    .modal {
        display: none;
        position: fixed;
        z-index: 1000;
        left: 0;
        top: 0;
        width: 100%;
        height: 100%;
        background-color: rgba(0,0,0,0.4);
    }

    .modal-content {
        background-color: #fefefe;
        margin: 15% auto;
        padding: 20px;
        border: 1px solid #888;
        width: 80%;
        max-width: 500px;
        border-radius: 8px;
    }

    .close {
        color: #aaa;
        float: right;
        font-size: 28px;
        font-weight: bold;
        cursor: pointer;
    }

    .week {
        display: flex;
        justify-content: space-between;
        margin-bottom: 10px;
    }

    .calendar-day {
        display: inline-block;
        width: 40px;
        height: 40px;
        margin: 2px;
        text-align: center;
        line-height: 40px;
        cursor: pointer;
        border-radius: 50%;
    }

    .day-green { background-color: #d4edda; }
    .day-red { background-color: #f8d7da; }
    .day-gray {
        background-color: #e9ecef;
        cursor: not-allowed;
    }

    .calendar-btn {
        margin-left: 5px;
        padding: 0.2rem 0.5rem;
        font-size: 0.8rem;
        border-radius: 50%;
        border: 1px solid #ddd;
        background-color: white;  /* Changed from transparent */
        color: #666;
        box-shadow: 0 1px 3px rgba(0,0,0,0.1);  /* Adding subtle shadow */
    }

    .calendar-day-header {
        display: inline-block;
        width: 40px;
        height: 30px;
        margin: 2px;
        text-align: center;
        line-height: 30px;
        font-weight: bold;
        font-size: 0.9rem;
        color: #666;
    }

    .day-today {
        border: 2px solid #0d6efd;  /* Bootstrap primary blue */
    }


    /* Button Styles */
    .btn-outline-secondary {
        background-color: #e9ecef;
        border-color: #e9ecef;
        color: #6c757d;
    }

    .btn-outline-secondary:disabled {
        cursor: not-allowed;
    }

    .status-button {
        font-size: 0.8rem;
        padding: 0.2rem 0.8rem;
        background-color: white;  /* Adding white background */
        box-shadow: 0 1px 3px rgba(0,0,0,0.1);  /* Adding subtle shadow */
    }

    .status-button:disabled {
        opacity: 0.7;
        cursor: wait;
    }

    @keyframes warningPulse {
        0% { opacity: 1; }
        50% { opacity: 0.5; }
        100% { opacity: 1; }
    }

    .fa-exclamation-triangle {
        animation: warningPulse 2s infinite;
    }


    .status-button-disabled {
        cursor: not-allowed;
    }

    /* Icon Styles */
    .icon-active {
        color: #28a745;
    }

    .icon-inactive {
        color: #dc3545;
    }

    .icon-disabled {
        color: #6c757d;  /* Bootstrap's secondary gray color */
    }

    /* Traffic Light Icons */
    .traffic-light {
        margin-right: 0.5rem;
    }

    /* Add this to your existing style section */
    @keyframes highlightChange {
        0% { transform: scale(1); }
        50% { transform: scale(1.05); background-color: #fff3cd; }
        100% { transform: scale(1); }
    }

    .highlight-change {
        animation: highlightChange 1.5s ease-in-out;
    }

    .warning-icon {
        color: #dc3545; /* Bootstrap's danger color */
        background-color: #fff; /* White background for contrast */
        padding: 2px; /* Padding for better visibility */
        margin-right: 8px; /* Space between icon and button */
        border-radius: 50%; /* Optional: round the icon */
    }

</style>

<script>
    let currentParticipantId = null;
    let lastUpdateTimestamp = 0;
    const UPDATE_THRESHOLD = 1000; // Minimum time (ms) between updates
    let globalEventSource = null;
    let locallyChangedParticipants = new Set(); // For animations
    let isWalkingBusDay = false;
    const WEEKDAY_MAPPING = {
        0: 'monday',
        1: 'tuesday',
        2: 'wednesday',
        3: 'thursday',
        4: 'friday',
        5: 'saturday',
        6: 'sunday'
    };


    document.addEventListener('DOMContentLoaded', async () => {
        // Create and insert alert container
        const alertsContainer = document.createElement('div');
        alertsContainer.id = 'alerts-container';
        alertsContainer.innerHTML = `
            <div id="connection-alert" class="alert alert-danger d-none" role="alert">
                <i class="fas fa-exclamation-triangle me-2"></i>
                Die Verbindung zum Server wurde unterbrochen. Die angezeigten Daten sind möglicherweise nicht aktuell.
            </div>
            <div id="walkingbus-alert" class="alert alert-info d-none" role="alert">
                <i class="fas fa-info-circle me-2"></i>
                Heute findet kein Walking Bus statt.
            </div>
        `;

        const stationsDiv = document.getElementById('stations');
        stationsDiv.parentNode.insertBefore(alertsContainer, stationsDiv);

        // Initialize IndexedDB first
        await initDB();
        
        // Initialize data and connections
        await loadStations();
        initializeSSE();
        console.log('SSE initialization completed');

        // Setup modal handling
        const modal = document.getElementById('calendarModal');
        const span = document.getElementsByClassName('close')[0];

        span.onclick = () => modal.style.display = 'none';
        window.onclick = (event) => {
            if (event.target === modal) {
                modal.style.display = 'none';
            }
        };

        // Add offline/online handlers
        window.addEventListener('online', () => {
            loadStations();
        });

        window.addEventListener('offline', () => {
            updateConnectionStatus('disconnected');
        });
    });



    // First, create a promise for database initialization
    let dbPromise;

    function initDB() {
        dbPromise = new Promise((resolve, reject) => {
            const request = indexedDB.open('WalkingBusDB', 3);
            
            request.onerror = () => reject(request.error);
            
            request.onsuccess = (event) => {
                const db = event.target.result;
                resolve(db);
            };
            
            request.onupgradeneeded = (event) => {
                const db = event.target.result;
                // Add existing stores
                if (!db.objectStoreNames.contains('stationsData')) {
                    db.createObjectStore('stationsData', { keyPath: 'timestamp' });
                }
                if (!db.objectStoreNames.contains('participantStates')) {
                    db.createObjectStore('participantStates', { keyPath: 'id' });
                }
                // Add new store for calendar data
                if (!db.objectStoreNames.contains('calendarData')) {
                    db.createObjectStore('calendarData', { keyPath: ['participantId', 'date'] });
                }
            };
        });
        return dbPromise;
    }


    async function loadStations() {
        const now = Date.now();
        if (now - lastUpdateTimestamp < UPDATE_THRESHOLD) {
            return;
        }
        lastUpdateTimestamp = now;

        try {
            const db = await dbPromise;
            const response = (await axios.post('/api/initialize-daily-status')).data;
            isWalkingBusDay = response.isWalkingBusDay;
            const stations = (await axios.get('/api/stations')).data;

            // Get previous states
            const previousStates = await getPreviousStates(db);
            
            // Store new states
            const transaction = db.transaction(['participantStates'], 'readwrite');
            const store = transaction.objectStore('participantStates');
            
            // Create array of changed participants
            const changedParticipants = [];
            stations.forEach(station => {
                station.participants.forEach(participant => {
                    const previousState = previousStates[participant.id];
                    if (previousState !== undefined && 
                        previousState.today_status !== participant.today_status) {
                        changedParticipants.push(participant.id);
                    }
                    store.put({
                        id: participant.id,
                        today_status: participant.today_status
                    });
                });
            });

            renderStations(stations, isWalkingBusDay);
            
            // Highlight changed participants
            highlightChangedParticipants(changedParticipants);
            
            updateConnectionStatus('connected');
        } catch (error) {
            // ... existing error handling ...
        }
    }

    function renderStations(stations, isWalkingBusDay) {
        // Show/hide walking bus alert
        const walkingbusAlert = document.getElementById('walkingbus-alert');
        walkingbusAlert.classList.toggle('d-none', isWalkingBusDay);

        const stationsContainer = document.getElementById('stations');
        stationsContainer.innerHTML = '';

        stations.forEach(station => {
            const stationDiv = document.createElement('div');
            stationDiv.classList.add('station-card');
            stationDiv.innerHTML = createStationHeader(station, isWalkingBusDay);

            const list = document.createElement('ul');
            list.classList.add('list-group', 'list-group-flush', 'participants-list');
            list.dataset.stationId = station.id;

            station.participants.forEach(participant => {
                const item = createParticipantItem(participant, isWalkingBusDay);
                const nameSpan = createNameSpan(participant, isWalkingBusDay);

                const buttonContainer = document.createElement('div');
                buttonContainer.classList.add('d-flex', 'align-items-center');

                const statusButton = createStatusButton(participant, isWalkingBusDay);
                const calendarButton = document.createElement('button');
                calendarButton.classList.add('calendar-btn');
                calendarButton.innerHTML = '<i class="fas fa-calendar-alt"></i>';
                calendarButton.onclick = (e) => {
                    e.stopPropagation();
                    openCalendar(participant.id);
                };

                buttonContainer.append(statusButton, calendarButton);
                item.append(nameSpan, buttonContainer);
                list.appendChild(item);
            });

            stationDiv.appendChild(list);
            stationsContainer.appendChild(stationDiv);
        });
    }


    function createStationHeader(station, isWalkingBusDay) {
        return `
            <div class="station-header">
                <h5 class="d-flex justify-content-between align-items-center mb-0">
                    <span>
                        <i class="fas fa-bus-simple me-2"></i>
                        ${station.name}
                    </span>
                    <span class="badge bg-light text-dark" id="stats-station-${station.id}">
                        ${getStationStats(station)}
                    </span>
                </h5>
            </div>`;
    }

    function createParticipantItem(participant, isWalkingBusDay) {
        const item = document.createElement('li');
        item.classList.add(
            'list-group-item',
            'py-1',
            'd-flex',
            'justify-content-between',
            'align-items-center',
            'participant-item'
        );

        item.classList.add(
            isWalkingBusDay
                ? (participant.today_status ? 'participant-status-active' : 'participant-status-inactive')
                : 'participant-status-disabled'
        );

        item.dataset.participantId = participant.id;
        return item;
    }

    function createNameSpan(participant, isWalkingBusDay) {
        const nameSpan = document.createElement('span');
        nameSpan.classList.add('text-truncate', 'me-2', 'participant-name');

        const icon = document.createElement('i');
        icon.classList.add('fas', 'me-2', 'traffic-light');

        if (!isWalkingBusDay) {
            icon.classList.add('fa-person', 'icon-disabled');  // Changed to icon-disabled
        } else {
            icon.classList.add(
                participant.today_status ? 'fa-walking' : 'fa-person',
                participant.today_status ? 'icon-active' : 'icon-inactive'
            );
        }

        nameSpan.appendChild(icon);
        nameSpan.appendChild(document.createTextNode(participant.name));
        return nameSpan;
    }

    function createStatusButton(participant, isWalkingBusDay) {
        const button = document.createElement('button');
        button.classList.add(
            'btn', 
            'btn-sm', 
            'rounded-pill', 
            'status-button',
            'touch-target'  // New class for better touch area
        );

        if (!isWalkingBusDay) {
            button.classList.add('btn-outline-secondary', 'status-button-disabled');
            button.innerHTML = '<i class="fas fa-times"></i>';
        } else {
            button.classList.add(participant.today_status ? 'btn-outline-danger' : 'btn-outline-success');
            button.innerHTML = participant.today_status ? '<i class="fas fa-times"></i>' : '<i class="fas fa-check"></i>';
            button.onclick = (e) => {
                e.preventDefault();  // Prevent any default behavior
                toggleParticipation(participant.id, button);
            };
        }

        return button;
    }

    function getStationStats(station) {
        const totalParticipants = station.participants.length;
        const confirmedParticipants = isWalkingBusDay ? 
            station.participants.filter(p => p.today_status).length : 0;
        return `${confirmedParticipants} / ${totalParticipants}`;
    }

    function updateStationStats(stationId) {
        fetch(`/api/stations/${stationId}/stats`)
            .then(response => {
                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }
                return response.json();
            })
            .then(data => {
                const statsElement = document.getElementById(`stats-station-${stationId}`);
                if (statsElement) {
                    statsElement.textContent = `${data.active} / ${data.total}`;
                }
            })
            .catch(error => {
                console.error('Stats update failed:', error);
                // Optionally update UI to show error state
            });
    }

    async function getStatusForDay(participantId, date) {
        console.log('Getting status for:', {
            date: date.toISOString(),
            localDate: date.toLocaleString(),
            dayOfWeek: date.getDay(),
            weekday: WEEKDAY_MAPPING[date.getDay()]
        });
        try {
            const response = await axios.get(`/api/calendar-status/${participantId}`);
            const dateStr = date.toISOString().split('T')[0];
            const entry = response.data.find(e => e.date === dateStr);

            if (entry) {
                return entry.status;
            }

            const dayNumber = date.getDay();
            const weekday = WEEKDAY_MAPPING[dayNumber];

            if (weekday) {
                const defaultStatusResponse = await axios.get(`/api/participant/${participantId}/weekday-status/${weekday}`);
                return defaultStatusResponse.data.status;
            }

            return false;
        } catch (error) {
            console.error('Error fetching calendar status:', error);
            return false;
        }
    }

    // Modify the toggleParticipation function to track local changes
    async function toggleParticipation(participantId, button) {
        locallyChangedParticipants.add(participantId);
        // Save original button content for restoration if needed
        const originalButtonContent = button.innerHTML;
        
        // Show loading state
        button.innerHTML = '<i class="fas fa-spinner fa-spin"></i>';
        button.disabled = true;
        
        try {
            // Attempt server update
            const response = await axios.patch(`/api/participation/${participantId}`);
            
            // Server confirmed the change
            const newStatus = response.data.status_today;
            
            // Execute flip animation and update UI
            const listItem = button.closest('.participant-item');
            listItem.classList.add('status-changing');
            
            setTimeout(() => {
                updateParticipantUI(button, newStatus);
                button.disabled = false;
                button.innerHTML = newStatus ? 
                    '<i class="fas fa-times"></i>' : 
                    '<i class="fas fa-check"></i>';
            }, 400);
            
            // Update calendar if open
            if (document.getElementById('calendarModal').style.display === 'block') {
                await renderCalendar();
            }
            
        } catch (error) {
            // Error handling
            console.error('Error toggling participation:', error);

            // Restore original button state
            button.disabled = false;
            button.innerHTML = originalButtonContent;

            // Show warning indicator
            const warningIcon = document.createElement('i');
            warningIcon.classList.add('fas', 'fa-exclamation-triangle', 'warning-icon');
            warningIcon.title = 'Änderung fehlgeschlagen. Bitte erneut versuchen.';

            const buttonContainer = button.parentElement;

            // Append the warning icon before the button
            buttonContainer.insertBefore(warningIcon, buttonContainer.firstChild);

            // Remove warning after 5 seconds
            setTimeout(() => {
                warningIcon.remove();
            }, 5000);

        }
    }


    function updateParticipantUI(button, status) {
        const listItem = button.closest('.participant-item');
        const stationList = button.closest('.participants-list');
        const stationId = stationList.dataset.stationId;
        
        // Get the current stats element
        const statsElement = document.getElementById(`stats-station-${stationId}`);
        const [active, total] = statsElement.textContent.split(' / ').map(Number);
        
        // Immediately update the stats based on the new status
        // If status is true (active), increment, if false (inactive), decrement
        const newActive = status ? active + 1 : active - 1;
        statsElement.textContent = `${newActive} / ${total}`;

        // Rest of the existing updateParticipantUI code...
        listItem.classList.add('status-changing');
        
        setTimeout(() => {
            listItem.classList.toggle('participant-status-active', status);
            listItem.classList.toggle('participant-status-inactive', !status);
            // ... rest of the setTimeout code
        }, 400);

        // Remove animation class after completion
        listItem.addEventListener('animationend', () => {
            listItem.classList.remove('status-changing');
        }, { once: true });
    }



    async function openCalendar(participantId) {
        currentParticipantId = participantId;
        const modal = document.getElementById('calendarModal');

        // Setup modal content first
        const calendarButton = event.target;
        const participantItem = calendarButton.closest('.participant-item');
        const participantName = participantItem.querySelector('.text-truncate').textContent.trim();

        const modalContent = modal.querySelector('.modal-content');
        modalContent.innerHTML = `
            <div class="d-flex justify-content-between align-items-center p-3 border-bottom">
                <span class="close" onclick="document.getElementById('calendarModal').style.display='none'">×</span>
                <h4 class="mb-0 ms-3">${participantName}</h4>
            </div>
            <div id="calendar"></div>
        `;

        try {
            // Try online first
            const response = await fetch(`/api/calendar-data/${participantId}`);
            if (response.ok) {
                const calendarData = await response.json();
                // Store in IndexedDB for offline use
                const db = await dbPromise;
                const tx = db.transaction('calendarData', 'readwrite');
                const store = tx.objectStore('calendarData');
                
                for (const day of calendarData) {
                    await store.put({
                        participantId,
                        date: day.date,
                        status: day.status,
                        is_schedule_day: day.is_schedule_day,
                        is_past: day.is_past,
                        is_today: day.is_today
                    });
                }
                await renderCalendar(calendarData);
            } else {
                throw new Error('Network response was not ok');
            }
        } catch (error) {
            // Offline fallback
            const db = await dbPromise;
            const tx = db.transaction('calendarData', 'readonly');
            const store = tx.objectStore('calendarData');
            const range = IDBKeyRange.bound(
                [participantId, ""], 
                [participantId, "\uffff"]
            );
            const request = store.getAll(range);
            
            const offlineData = await new Promise((resolve, reject) => {
                request.onsuccess = () => resolve(request.result);
                request.onerror = () => reject(request.error);
            });

            // Transform offline data to match online format
            const transformedData = offlineData.map(item => ({
                date: item.date,
                status: item.status,
                is_schedule_day: item.is_schedule_day,
                is_past: item.is_past,
                is_today: item.is_today
            }));

            await renderCalendar(transformedData);
        }

        modal.style.display = 'block';
    }



    async function initializeDailyStatus() {
        try {
            const response = await axios.post('/api/initialize-daily-status');
            return response.data.currentDate;
        } catch (error) {
            console.error('Error initializing daily status:', error);
        }
    }

    async function renderCalendar(calendarData) {
        const calendar = document.getElementById('calendar');
        calendar.innerHTML = '';

        // Generate 4 weeks of dates starting from current week
        const today = new Date();
        const startOfWeek = new Date(today);
        startOfWeek.setDate(today.getDate() - today.getDay() + 1); // Start from Monday

        // Create weekday header
        const weekdayHeader = document.createElement('div');
        weekdayHeader.className = 'week';
        ['Mo', 'Di', 'Mi', 'Do', 'Fr', 'Sa', 'So'].forEach(day => {
            const dayHeader = document.createElement('div');
            dayHeader.className = 'calendar-day-header';
            dayHeader.textContent = day;
            weekdayHeader.appendChild(dayHeader);
        });
        calendar.appendChild(weekdayHeader);

        // Generate calendar days
        for (let weekIndex = 0; weekIndex < 4; weekIndex++) {
            const weekDiv = document.createElement('div');
            weekDiv.className = 'week';

            for (let dayIndex = 0; dayIndex < 7; dayIndex++) {
                const currentDate = new Date(startOfWeek);
                currentDate.setDate(startOfWeek.getDate() + (weekIndex * 7) + dayIndex);
                const dateStr = currentDate.toISOString().split('T')[0];

                const dayDiv = document.createElement('div');
                dayDiv.className = 'calendar-day';
                dayDiv.textContent = currentDate.getDate();

                // Find matching data for this date
                const dayData = calendarData.find(d => d.date === dateStr) || {
                    date: dateStr,
                    status: false,
                    is_schedule_day: currentDate.getDay() !== 0 && currentDate.getDay() !== 6,
                    is_past: currentDate < today,
                    is_today: dateStr === today.toISOString().split('T')[0]
                };

                if (!dayData.is_schedule_day || dayData.is_past) {
                    dayDiv.classList.add('day-gray');
                } else {
                    dayDiv.classList.add(dayData.status ? 'day-green' : 'day-red');
                    dayDiv.onclick = () => toggleDayStatus(currentParticipantId, dateStr, dayDiv);
                }

                if (dayData.is_today) {
                    dayDiv.classList.add('day-today');
                }

                weekDiv.appendChild(dayDiv);
            }

            calendar.appendChild(weekDiv);
        }
    }


    async function toggleDayStatus(participantId, dateString, dayDiv) {
        const newStatus = !dayDiv.classList.contains('day-green');
        
        // Store original content
        const originalContent = dayDiv.textContent;
        // Show loading state
        dayDiv.innerHTML = '<i class="fas fa-spinner fa-spin"></i>';
        
        try {
            await axios.post('/api/calendar-status', {
                participant_id: participantId,
                date: dateString,
                status: newStatus
            });
            
            // Success - update UI
            dayDiv.textContent = originalContent;
            dayDiv.classList.toggle('day-green');
            dayDiv.classList.toggle('day-red');
            
            // Update IndexedDB
            const db = await dbPromise;
            const tx = db.transaction('calendarData', 'readwrite');
            const store = tx.objectStore('calendarData');
            await store.put({
                participantId,
                date: dateString,
                status: newStatus
            });
            
        } catch (error) {
            // Error - show warning triangle
            dayDiv.innerHTML = '<i class="fas fa-exclamation-triangle text-warning"></i>';
            dayDiv.title = 'Änderung konnte nicht gespeichert werden';
            
            // Restore original state after 3 seconds
            setTimeout(() => {
                dayDiv.textContent = originalContent;
            }, 3000);
        }
    }


    // Modify initializeSSE to handle mobile focus better
    function initializeSSE() {
        console.log('Starting SSE connection...');
        if (globalEventSource) {
            globalEventSource.close();
        }
        
        globalEventSource = new EventSource('/stream');
        
        let reconnectAttempts = 0;
        const maxReconnectAttempts = 5;
        let connectionAlertTimeout;
        const alertDelay = 10000; // 10 seconds delay
        
        globalEventSource.onmessage = (event) => {
            console.log('Received SSE update:', event.data);
            const data = JSON.parse(event.data);
            if (data.time) {
                document.getElementById('current-time').textContent = data.time;
            }
            loadStations();
            updateConnectionStatus('connected');
            reconnectAttempts = 0;
            if (connectionAlertTimeout) {
                clearTimeout(connectionAlertTimeout);
                connectionAlertTimeout = null;
            }
        };

        globalEventSource.addEventListener('error', (event) => {
            console.error('SSE connection error:', event);
            updateConnectionStatus('disconnected');
            
            if (reconnectAttempts < maxReconnectAttempts) {
                reconnectAttempts++;
                setTimeout(() => {
                    console.log(`Attempting to reconnect (${reconnectAttempts}/${maxReconnectAttempts})...`);
                    globalEventSource.close();
                    initializeSSE();
                }, 5000 * reconnectAttempts);
            }
        });

        // Add mobile-specific event listeners
        document.addEventListener('focus', handlePageFocus);
        document.addEventListener('resume', handlePageFocus);
        
        function handlePageFocus() {
            loadStations();
            if (connectionAlertTimeout) {
                clearTimeout(connectionAlertTimeout);
                connectionAlertTimeout = null;
            }
        }

        return globalEventSource;
    }

    // Add visibility change handling for mobile users
    document.addEventListener('visibilitychange', () => {
        if (!document.hidden) {
            // Clear any existing alert immediately
            const connectionAlert = document.getElementById('connection-alert');
            connectionAlert.classList.add('d-none');
            
            // Force data refresh
            loadStations();
            
            // Reset SSE connection
            if (eventSource) {
                eventSource.close();
            }
            initializeSSE();
        }
    });


    function updateConnectionStatus(status) {
        const connectionAlert = document.getElementById('connection-alert');
        const connectionIndicator = document.querySelector('.connection-indicator');
        
        // Only update alert if we're actively showing the page
        if (!document.hidden) {
            connectionAlert.classList.toggle('d-none', status === 'connected');
        }
        
        connectionIndicator.classList.remove('connected', 'disconnected');
        connectionIndicator.classList.add(status === 'connected' ? 'connected' : 'disconnected');
    }

    // Helper function to get previous states
    async function getPreviousStates(db) {
        return new Promise((resolve) => {
            const transaction = db.transaction(['participantStates'], 'readonly');
            const store = transaction.objectStore('participantStates');
            const request = store.getAll();
            
            request.onsuccess = () => {
                const states = {};
                request.result.forEach(item => {
                    states[item.id] = item;
                });
                resolve(states);
            };
            
            request.onerror = () => resolve({});
        });
    }


    // Function to highlight changed participants
    // Modify the highlight function to add sequential delays
    function highlightChangedParticipants(changedIds) {
        // Filter out locally changed participants
        const remoteChanges = changedIds.filter(id => !locallyChangedParticipants.has(id));
        
        const DELAY_BETWEEN_ANIMATIONS = 200;

        remoteChanges.forEach((id, index) => {
            const element = document.querySelector(`[data-participant-id="${id}"]`);
            if (element) {
                setTimeout(() => {
                    element.classList.add('highlight-change');
                    element.addEventListener('animationend', () => {
                        element.classList.remove('highlight-change');
                    }, { once: true });
                }, index * DELAY_BETWEEN_ANIMATIONS);
            }
        });
    }
</script>

<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.1/css/all.min.css">
{% endblock %}
