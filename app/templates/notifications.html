{% extends "base.html" %}

{% block content %}
<div class="container mt-4">
    <!-- Toast -->
    <div class="toast-container position-fixed bottom-0 end-0 p-3">
        <div id="notificationToast" class="toast" role="alert" aria-live="assertive" aria-atomic="true">
            <div class="toast-header">
                <i id="toastIcon" class="fas me-2"></i>
                <strong class="me-auto">Walking Bus</strong>
                <button type="button" class="btn-close" data-bs-dismiss="toast" aria-label="Close"></button>
            </div>
            <div class="toast-body"></div>
        </div>
    </div>
    
    <!-- Info Box -->
    <div class="alert alert-info" role="alert">
        <i class="fas fa-info-circle me-2"></i>
        Wähle hier die Teilnehmer, für die Du Erinnerungen erhalten möchtest. Du wirst automatisch eine Stunde vor Beginn des Walking Bus eine Erinnerung erhalten.
    </div>

    <!-- Requirements Check -->
    <div class="card mb-4">
        <div class="card-header">
            <h5 class="mb-0">Systemvoraussetzungen</h5>
        </div>
        <div class="card-body">
            <ul class="list-group">
                <li class="list-group-item d-flex align-items-center" id="pwaCheck">
                    <span class="status-icon me-2">
                        <i class="fas fa-spinner fa-spin"></i>
                    </span>
                    <span class="flex-grow-1">App Installation Status</span>
                </li>
                <li class="list-group-item d-flex align-items-center" id="notificationCheck">
                    <span class="status-icon me-2">
                        <i class="fas fa-spinner fa-spin"></i>
                    </span>
                    <span class="flex-grow-1">Benachrichtigungen</span>
                </li>
            </ul>
        </div>
    </div>

    <!-- Participant Selection -->
    <div class="card">
        <div class="card-header">
            <h5 class="mb-0">Teilnehmer auswählen</h5>
        </div>
            <div class="card-body">
                {% if stations %}
                <!-- Debug info -->
                <div class="d-none">
                    Found {{ stations|length }} stations:
                    {% for station in stations %}
                        Station: {{ station.name }} ({{ station.participants|length }} participants)
                    {% endfor %}
                </div>
            
                <!-- Existing participant section -->
                {% for station in stations %}
                <div class="station-group mb-4">
                    <h6 class="station-name mb-3">{{ station.name }}</h6>
                    <div class="participant-list">
                        {% for participant in station.participants %}
                        <div class="form-check mb-2">
                            <input class="form-check-input participant-checkbox" 
                                type="checkbox" 
                                value="{{ participant.id }}" 
                                id="participant{{ participant.id }}">
                            <label class="form-check-label" for="participant{{ participant.id }}">
                                {{ participant.name }}
                            </label>
                        </div>
                        {% endfor %}
                    </div>
                </div>
                {% endfor %}
            {% else %}
                <div class="alert alert-info">
                    Keine Stationen oder Teilnehmer gefunden.
                </div>
            {% endif %}
            
        </div>
    </div>

    <!-- Test Notification -->
    <div class="card mt-4">
        <div class="card-header">
            <h5 class="mb-0">Test Benachrichtigungen</h5>
        </div>
        <div class="card-body">
            <p class="text-muted">Hier können Sie die Benachrichtigungen für die ausgewählten Teilnehmer testen.</p>
            <button id="testNotification" class="btn btn-secondary">
                <i class="fas fa-bell me-2"></i>Test-Benachrichtigung senden
            </button>
        </div>
    </div>
</div>


<script>
class NotificationManager {
    constructor() {
        this.vapidPublicKey = null;
    }

    async init() {
        console.log('[NOTI.HTML] Initializing NotificationManager');
        if (!('serviceWorker' in navigator) || !('PushManager' in window)) {
            throw new Error('Push notifications are not supported');
        }
        await this.getVapidKey();
    }

    async getVapidKey() {
        try {
            const response = await fetchWithAuth('/api/notifications/vapid-key');
            if (!response.ok) {
                throw new Error('Failed to fetch VAPID key');
            }
            this.vapidPublicKey = await response.text();
            console.log('[NOTI.HTML] Successfully retrieved VAPID key');
            return this.vapidPublicKey;
        } catch (error) {
            console.error('[NOTI.HTML] Error fetching VAPID key:', error);
            throw error;
        }
    }


    async subscribeUserToPush(participantIds) {
        try {
            console.log('[NOTI.HTML] Starting subscription process');
            
            const permission = await Notification.requestPermission();
            console.log('[NOTI.HTML] Permission status:', permission);
            
            if (permission !== 'granted') {
                throw new Error('Notification permission denied');
            }

            if ('serviceWorker' in navigator) {
                console.log('[NOTI.HTML] Service Worker available');
                
                // Initialize service worker first
                const registration = await navigator.serviceWorker.register('/static/service-worker.js');
                console.log('[NOTI.HTML] Service Worker registered');
                
                // Wait for activation
                if (registration.installing) {
                    await new Promise(resolve => {
                        registration.installing.addEventListener('statechange', e => {
                            if (e.target.state === 'activated') resolve();
                        });
                    });
                }
                console.log('[NOTI.HTML] Service Worker activated');
                
                // Check for existing subscription and unsubscribe if needed
                let subscription = await registration.pushManager.getSubscription();
                if (subscription) {
                    console.log('[NOTI.HTML] Found existing subscription, unsubscribing');
                    await subscription.unsubscribe();
                }
                
                // Create new subscription
                subscription = await registration.pushManager.subscribe({
                    userVisibleOnly: true,
                    applicationServerKey: this.vapidPublicKey
                });
                console.log('[NOTI.HTML] Subscription created:', subscription);

                // Send to server
                await fetchWithAuth('/api/notifications/subscription', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        subscription: subscription,
                        participantIds: participantIds
                    })
                });
                
                return true;
            }
        } catch (error) {
            console.error('[NOTI.HTML] Error:', error);
            throw error;
        }
    }


    async loadExistingSubscriptions() {
        console.log('[NOTI.HTML] Loading existing subscriptions');
        const response = await fetchWithAuth('/api/notifications/subscription');
        const data = await response.json();
        
        if (data && data.participantIds) {
            console.log('[NOTI.HTML] Found subscriptions for:', data.participantIds);
            // Check the corresponding checkboxes
            data.participantIds.forEach(id => {
                const checkbox = document.querySelector(`#participant${id}`);
                if (checkbox) {
                    checkbox.checked = true;
                }
            });
        }
    }

    async handleParticipantChange() {
        const selectedIds = Array.from(document.querySelectorAll('.participant-checkbox:checked'))
            .map(cb => parseInt(cb.value));
        
        console.log('[NOTI.HTML] Selected participants changed:', selectedIds);
        
        if (selectedIds.length === 0) {
            // No participants selected - unsubscribe completely
            console.log('[NOTI.HTML] No participants selected, unsubscribing');
            await this.unsubscribeFromPush();
            showToast('Benachrichtigungen deaktiviert', 'info');
        } else {
            // Update subscription with new participant selection
            console.log('[NOTI.HTML] Updating subscription with new participants');
            await this.subscribeUserToPush(selectedIds);
            showToast('Einstellungen aktualisiert', 'success');
        }
    }

    async cleanupSubscription(subscription) {
        try {
            // 1. Unsubscribe from browser
            await subscription.unsubscribe();
            console.log('[NOTI.HTML] Unsubscribed from push service');
            
            // 2. Delete from backend BEFORE loading subscriptions
            await fetchWithAuth('/api/notifications/subscription', {
                method: 'DELETE',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ endpoint: subscription.endpoint })
            });
            console.log('[NOTI.HTML] Removed server subscription');
            
            // 3. Clear checkboxes
            document.querySelectorAll('.participant-checkbox').forEach(checkbox => {
                checkbox.checked = false;
            });
            
            // 4. Wait for backend cleanup to complete before proceeding
            await new Promise(resolve => setTimeout(resolve, 100));
            
            showToast('Benachrichtigungen wurden zurückgesetzt', 'info');
        } catch (error) {
            console.error('[NOTI.HTML] Cleanup error:', error);
        }
    }

    async validateAndCleanupSubscriptions() {
        console.log('[NOTI.HTML] Validating existing subscriptions');
        
        if (!this.vapidPublicKey) {
            await this.getVapidKey();
        }
        
        if ('serviceWorker' in navigator) {
            try {
                const registration = await navigator.serviceWorker.register('/static/service-worker.js');
                
                if (registration.installing) {
                    await new Promise(resolve => {
                        registration.installing.addEventListener('statechange', e => {
                            if (e.target.state === 'activated') resolve();
                        });
                    });
                }
                console.log('[NOTI.HTML] Service Worker activated');
                
                const subscription = await registration.pushManager.getSubscription();
                
                if (subscription) {
                    // Convert current key to URL-safe base64
                    const currentKey = this.arrayBufferToBase64(subscription.options.applicationServerKey)
                        .replace(/=/g, '')
                        .replace(/\+/g, '-')
                        .replace(/\//g, '_');
                    
                    console.log('[NOTI.HTML] Current key:', currentKey);
                    console.log('[NOTI.HTML] New key:', this.vapidPublicKey);
                    
                    if (currentKey !== this.vapidPublicKey) {
                        console.log('[NOTI.HTML] VAPID key mismatch - cleaning up');
                        await this.cleanupSubscription(subscription);
                    } else {
                        console.log('[NOTI.HTML] VAPID keys match');
                    }
                }
            } catch (error) {
                console.error('[NOTI.HTML] Validation error:', error);
                showToast('Fehler bei der Überprüfung der Benachrichtigungen', 'error');
            }
        }
    }

    arrayBufferToBase64(buffer) {
        const bytes = new Uint8Array(buffer);
        return btoa(String.fromCharCode.apply(null, bytes));
    }

    async unsubscribeFromPush() {
        if ('serviceWorker' in navigator) {
            const activeWorker = await initializeServiceWorker();
            const registration = await navigator.serviceWorker.ready;
            const subscription = await registration.pushManager.getSubscription();
            
            if (subscription) {
                await subscription.unsubscribe();
                
                await fetchWithAuth('/api/notifications/subscription', {
                    method: 'DELETE',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        endpoint: subscription.endpoint
                    })
                });
                
                return true;
            }
        }
        return false;
    }
}

// Helper function for service worker initialization
async function initializeServiceWorker() {
    console.log('[NOTI.HTML] Starting Service Worker initialization');
    const registration = await navigator.serviceWorker.register('/static/service-worker.js');

    if (registration.installing) {
        console.log('[NOTI.HTML] Service Worker installing');
        await new Promise(resolve => {
            registration.installing.addEventListener('statechange', e => {
                if (e.target.state === 'activated') {
                    console.log('[NOTI.HTML] Service Worker activated');
                    resolve();
                }
            });
        });
    }

    return registration.active;
}

// Create instance and initialize
const notificationManager = new NotificationManager();

document.addEventListener('DOMContentLoaded', async () => {
    try {
        console.log('[NOTI.HTML] DOM Content Loaded');

        // Initialize notification manager first
        await notificationManager.init();
        console.log('[NOTI.HTML] NotificationManager initialized');

        // Validate and cleanup subscriptions if needed
        await notificationManager.validateAndCleanupSubscriptions();
        console.log('[NOTI.HTML] Validate existing subscriptions');
        
        // Load existing subscriptions
        await notificationManager.loadExistingSubscriptions();
        console.log('[NOTI.HTML] Loaded existing subscriptions');

        // Initialize status checks
        const pwaCheckElement = document.getElementById('pwaCheck');
        const notificationCheckElement = document.getElementById('notificationCheck');
        console.log('[NOTI.HTML] Status elements found:', 
            { pwaCheck: !!pwaCheckElement, notificationCheck: !!notificationCheckElement });

        // Check PWA status
        const isPWA = window.matchMedia('(display-mode: standalone)').matches || 
                     window.navigator.standalone;
        console.log('[NOTI.HTML] PWA Status:', isPWA);
        updateStatusElement(pwaCheckElement, isPWA,
            'App ist installiert',
            'App muss noch installiert werden');

        // Check notification permission
        const notificationPermission = await checkNotificationPermission();
        console.log('[NOTI.HTML] Notification Permission:', notificationPermission);
        updateStatusElement(notificationCheckElement, notificationPermission === 'granted',
            'Benachrichtigungen sind aktiviert',
            'Benachrichtigungen müssen noch aktiviert werden');

        // Add change listeners to all participant checkboxes
        document.querySelectorAll('.participant-checkbox').forEach(checkbox => {
            checkbox.addEventListener('change', async () => {
                console.log('[NOTI.HTML] Checkbox changed');
                const selectedIds = Array.from(document.querySelectorAll('.participant-checkbox:checked'))
                    .map(cb => parseInt(cb.value));
                
                try {
                    if (selectedIds.length > 0) {
                        console.log('[NOTI.HTML] Updating subscription with:', selectedIds);
                        await notificationManager.subscribeUserToPush(selectedIds);
                        showToast('Einstellungen aktualisiert', 'success');
                    } else {
                        console.log('[NOTI.HTML] Unsubscribing - no participants selected');
                        await notificationManager.unsubscribeFromPush();
                        showToast('Benachrichtigungen deaktiviert', 'info');
                    }
                } catch (error) {
                    console.error('[NOTI.HTML] Error updating subscription:', error);
                    showToast('Fehler beim Aktualisieren', 'error');
                }
            });
        });

    } catch (error) {
        console.error('[NOTI.HTML] Initialization error:', error);
        showToast('Fehler bei der Initialisierung', 'error');
    }
});


function updateStatusElement(element, isSuccess, successText, failureText) {
    const iconSpan = element.querySelector('.status-icon');
    iconSpan.innerHTML = isSuccess ? 
        '<i class="fas fa-check-circle text-success"></i>' : 
        '<i class="fas fa-exclamation-circle text-warning"></i>';
    
    const textSpan = element.querySelector('.flex-grow-1');
    textSpan.textContent = isSuccess ? successText : failureText;
}

async function checkNotificationPermission() {
    if (!('Notification' in window)) return 'denied';
    return Notification.permission;
}

function showToast(message, type) {
    const toast = document.getElementById('notificationToast');
    const toastIcon = document.getElementById('toastIcon');
    const bsToast = new bootstrap.Toast(toast);
    
    // Set icon and color based on type
    switch(type) {
        case 'success':
            toastIcon.className = 'fas fa-check-circle text-success me-2';
            break;
        case 'error':
            toastIcon.className = 'fas fa-exclamation-circle text-danger me-2';
            break;
        case 'info':
            toastIcon.className = 'fas fa-info-circle text-info me-2';
            break;
        default:
            toastIcon.className = 'fas fa-bell me-2';
    }
    
    // Set message
    toast.querySelector('.toast-body').textContent = message;
    
    // Show toast
    bsToast.show();
}

document.getElementById('testNotification').addEventListener('click', async () => {
    const selectedIds = Array.from(document.querySelectorAll('.participant-checkbox:checked'))
        .map(cb => parseInt(cb.value));
        
    if (selectedIds.length === 0) {
        showToast('Bitte wählen Sie mindestens einen Teilnehmer aus', 'info');
        return;
    }

    try {
        const response = await fetchWithAuth('/api/notifications/test', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json'
            },
            body: JSON.stringify({ participantIds: selectedIds })
        });

        if (response.ok) {
            showToast('Test-Benachrichtigung wurde gesendet', 'success');
        } else {
            throw new Error('Fehler beim Senden der Test-Benachrichtigung');
        }
    } catch (error) {
        showToast('Fehler beim Senden der Test-Benachrichtigung', 'error');
        console.error(error);
    }
});

</script>
{% endblock %}