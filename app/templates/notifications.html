{% extends "base.html" %}

{% block content %}
<div class="container mt-4">
    <!-- Toast -->
    <div class="toast-container position-fixed bottom-0 end-0 p-3">
        <div id="notificationToast" class="toast" role="alert" aria-live="assertive" aria-atomic="true">
            <div class="toast-header">
                <i id="toastIcon" class="fas me-2"></i>
                <strong class="me-auto">Walking Bus</strong>
                <button type="button" class="btn-close" data-bs-dismiss="toast" aria-label="Close"></button>
            </div>
            <div class="toast-body"></div>
        </div>
    </div>
    
    <!-- Info Box -->
    <div class="alert alert-info" role="alert">
        <i class="fas fa-info-circle me-2"></i>
        Wähle hier die Teilnehmer, für die Du Erinnerungen erhalten möchtest. Du wirst automatisch eine Stunde vor Beginn des Walking Bus eine Erinnerung erhalten.
    </div>

    <!-- Requirements Check -->
    <div class="card mb-4">
        <div class="card-header">
            <h5 class="mb-0">Systemvoraussetzungen</h5>
        </div>
        <div class="card-body">
            <ul class="list-group">
                <li class="list-group-item d-flex align-items-center" id="pwaCheck">
                    <span class="status-icon me-2">
                        <i class="fas fa-spinner fa-spin"></i>
                    </span>
                    <span class="flex-grow-1">App Installation Status</span>
                </li>
                <li class="list-group-item d-flex align-items-center" id="notificationCheck">
                    <span class="status-icon me-2">
                        <i class="fas fa-spinner fa-spin"></i>
                    </span>
                    <span class="flex-grow-1">Benachrichtigungen</span>
                </li>
            </ul>
        </div>
        <div class="card-body">
            <div class="d-flex align-items-center mb-4">
                <button id="toggleNotifications" class="btn btn-primary me-3">
                    <i class="fas fa-bell me-2"></i>
                    <span class="status-text">Benachrichtigungen aktivieren</span>
                </button>
                <div id="subscriptionStatus" class="text-muted"></div>
            </div>
        </div>
    </div>

    <!-- Participant Selection -->
    <div class="card">
        <div class="card-header">
            <h5 class="mb-0">Teilnehmer auswählen</h5>
        </div>
            <div class="card-body">
                {% if stations %}
                <!-- Debug info -->
                <div class="d-none">
                    Found {{ stations|length }} stations:
                    {% for station in stations %}
                        Station: {{ station.name }} ({{ station.participants|length }} participants)
                    {% endfor %}
                </div>
            
                <!-- Existing participant section -->
                {% for station in stations %}
                <div class="station-group mb-4">
                    <h6 class="station-name mb-3">{{ station.name }}</h6>
                    <div class="participant-list">
                        {% for participant in station.participants %}
                        <div class="form-check mb-2">
                            <input class="form-check-input participant-checkbox" 
                                type="checkbox" 
                                value="{{ participant.id }}" 
                                id="participant{{ participant.id }}">
                            <label class="form-check-label" for="participant{{ participant.id }}">
                                {{ participant.name }}
                            </label>
                        </div>
                        {% endfor %}
                    </div>
                </div>
                {% endfor %}
            {% else %}
                <div class="alert alert-info">
                    Keine Stationen oder Teilnehmer gefunden.
                </div>
            {% endif %}

            <div class="d-grid gap-2 mt-3">
                <button id="saveSubscriptions" class="btn btn-primary" disabled>
                    <i class="fas fa-save me-2"></i>Änderungen speichern
                </button>
            </div>
            
        </div>
    </div>

    <!-- Test Notification -->
    <div class="card mt-4">
        <div class="card-header">
            <h5 class="mb-0">Test Benachrichtigungen</h5>
        </div>
        <div class="card-body">
            <p class="text-muted">Hier können Sie die Benachrichtigungen für die ausgewählten Teilnehmer testen.</p>
            <button id="testNotification" class="btn btn-secondary">
                <i class="fas fa-bell me-2"></i>Test-Benachrichtigung senden
            </button>
        </div>
    </div>

    <!-- Broadcast Message -->
    <div class="card mt-4">
        <div class="card-header">
            <h5 class="mb-0">Broadcast Nachricht</h5>
        </div>
        <div class="card-body">
            <div class="mb-3">
                <label for="broadcastMessage" class="form-label">Nachricht</label>
                <textarea class="form-control" id="broadcastMessage" rows="3" placeholder="Geben Sie Ihre Nachricht ein..."></textarea>
            </div>
            <button id="sendBroadcast" class="btn btn-primary">
                <i class="fas fa-broadcast-tower me-2"></i>Nachricht senden
            </button>
        </div>
    </div>

</div>


<script>
let pendingChanges = new Set(); // Track changed participant IDs

class NotificationManager {
    constructor() {
        this.vapidPublicKey = null;
    }

    async init() {
        console.log('[NOTI.HTML] Initializing NotificationManager');
        if (!('serviceWorker' in navigator) || !('PushManager' in window)) {
            throw new Error('Push notifications are not supported');
        }
        await this.getVapidKey();
    }

    async getVapidKey() {
        try {
            const response = await fetchWithAuth('/api/notifications/vapid-key');
            if (!response.ok) {
                throw new Error('Failed to fetch VAPID key');
            }
            this.vapidPublicKey = await response.text();
            console.log('[NOTI.HTML] Successfully retrieved VAPID key');
            return this.vapidPublicKey;
        } catch (error) {
            console.error('[NOTI.HTML] Error fetching VAPID key:', error);
            throw error;
        }
    }

    async checkSubscriptionStatus() {
        console.log('[NOTI] Checking subscription status');
        
        // Erst Service Worker registrieren und aktivieren
        const registration = await navigator.serviceWorker.register('/static/service-worker.js');
        
        // Auf Aktivierung warten
        if (registration.installing) {
            await new Promise(resolve => {
                registration.installing.addEventListener('statechange', e => {
                    if (e.target.state === 'activated') resolve();
                });
            });
        }
        console.log('[NOTI] Service Worker activated');
        
        // Jetzt erst Subscription prüfen
        const subscription = await registration.pushManager.getSubscription();
        this.subscriptionStatus = !!subscription;
        return this.subscriptionStatus;
    }


    async createNewSubscription() {
        console.log('[NOTI] Creating new subscription');
        
        const registration = await navigator.serviceWorker.register('/static/service-worker.js');
        
        if (registration.installing) {
            await new Promise(resolve => {
                registration.installing.addEventListener('statechange', e => {
                    if (e.target.state === 'activated') resolve();
                });
            });
        }
    
    const subscription = await registration.pushManager.subscribe({
        userVisibleOnly: true,
        applicationServerKey: this.vapidPublicKey
    });
    
    await this.saveSubscriptionToServer(subscription);
}


    async updateParticipantPreferences(participantIds) {
        await fetchWithAuth('/api/notifications/preferences', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ participantIds })
        });
    }


    async subscribeUserToPush(participantIds) {
        try {
            console.log('[NOTI.HTML] Starting subscription process');
            
            const permission = await Notification.requestPermission();
            console.log('[NOTI.HTML] Permission status:', permission);
            
            if (permission !== 'granted') {
                throw new Error('Notification permission denied');
            }

            if ('serviceWorker' in navigator) {
                console.log('[NOTI.HTML] Service Worker available');
                
                // Initialize service worker first
                const registration = await navigator.serviceWorker.register('/static/service-worker.js');
                console.log('[NOTI.HTML] Service Worker registered');
                
                // Wait for activation
                if (registration.installing) {
                    await new Promise(resolve => {
                        registration.installing.addEventListener('statechange', e => {
                            if (e.target.state === 'activated') resolve();
                        });
                    });
                }
                console.log('[NOTI.HTML] Service Worker activated');
                
                // Check for existing subscription and unsubscribe if needed
                let subscription = await registration.pushManager.getSubscription();
                if (subscription) {
                    console.log('[NOTI.HTML] Found existing subscription, unsubscribing');
                    await subscription.unsubscribe();
                }
                
                // Create new subscription
                subscription = await registration.pushManager.subscribe({
                    userVisibleOnly: true,
                    applicationServerKey: this.vapidPublicKey
                });
                console.log('[NOTI.HTML] Subscription created:', subscription);

                // Send to server
                await fetchWithAuth('/api/notifications/subscription', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        subscription: subscription,
                        participantIds: participantIds
                    })
                });
                
                return true;
            }
        } catch (error) {
            console.error('[NOTI.HTML] Error:', error);
            throw error;
        }
    }


    async loadExistingSubscriptions() {
        console.log('[NOTI.HTML] Loading existing subscriptions');
        const response = await fetchWithAuth('/api/notifications/subscription');
        const data = await response.json();

        await this.checkSubscriptionStatus();
        
        if (data && data.participantIds) {
            console.log('[NOTI.HTML] Found subscriptions for:', data.participantIds);
            // Check the corresponding checkboxes
            data.participantIds.forEach(id => {
                const checkbox = document.querySelector(`#participant${id}`);
                if (checkbox) {
                    checkbox.checked = true;
                }
            });
        }
    }

    async handleParticipantChange() {
        const selectedIds = Array.from(document.querySelectorAll('.participant-checkbox:checked'))
            .map(cb => parseInt(cb.value));
        
        console.log('[NOTI.HTML] Selected participants changed:', selectedIds);
        
        if (selectedIds.length === 0) {
            // No participants selected - unsubscribe completely
            console.log('[NOTI.HTML] No participants selected, unsubscribing');
            await this.unsubscribeFromPush();
            showToast('Benachrichtigungen deaktiviert', 'info');
        } else {
            // Update subscription with new participant selection
            console.log('[NOTI.HTML] Updating subscription with new participants');
            await this.subscribeUserToPush(selectedIds);
            showToast('Einstellungen aktualisiert', 'success');
        }
    }

    async cleanupSubscription(subscription) {
        try {
            // 1. Unsubscribe from browser
            await subscription.unsubscribe();
            console.log('[NOTI.HTML] Unsubscribed from push service');
            
            // 2. Delete from backend BEFORE loading subscriptions
            await fetchWithAuth('/api/notifications/subscription', {
                method: 'DELETE',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ endpoint: subscription.endpoint })
            });
            console.log('[NOTI.HTML] Removed server subscription');
            
            // 3. Clear checkboxes
            document.querySelectorAll('.participant-checkbox').forEach(checkbox => {
                checkbox.checked = false;
            });
            
            // 4. Wait for backend cleanup to complete before proceeding
            await new Promise(resolve => setTimeout(resolve, 100));
            
            showToast('Benachrichtigungen wurden zurückgesetzt', 'info');
        } catch (error) {
            console.error('[NOTI.HTML] Cleanup error:', error);
        }
    }

    async validateAndCleanupSubscriptions() {
        console.log('[NOTI.HTML] Validating existing subscriptions');
        
        if (!this.vapidPublicKey) {
            await this.getVapidKey();
        }
        
        if ('serviceWorker' in navigator) {
            try {
                const registration = await navigator.serviceWorker.register('/static/service-worker.js');
                
                if (registration.installing) {
                    await new Promise(resolve => {
                        registration.installing.addEventListener('statechange', e => {
                            if (e.target.state === 'activated') resolve();
                        });
                    });
                }
                console.log('[NOTI.HTML] Service Worker activated');
                
                const subscription = await registration.pushManager.getSubscription();
                
                if (subscription) {
                    // Convert current key to URL-safe base64
                    const currentKey = this.arrayBufferToBase64(subscription.options.applicationServerKey)
                        .replace(/=/g, '')
                        .replace(/\+/g, '-')
                        .replace(/\//g, '_');
                    
                    console.log('[NOTI.HTML] Current key:', currentKey);
                    console.log('[NOTI.HTML] New key:', this.vapidPublicKey);
                    
                    if (currentKey !== this.vapidPublicKey) {
                        console.log('[NOTI.HTML] VAPID key mismatch - cleaning up');
                        await this.cleanupSubscription(subscription);
                    } else {
                        console.log('[NOTI.HTML] VAPID keys match');
                    }
                }
            } catch (error) {
                console.error('[NOTI.HTML] Validation error:', error);
                showToast('Fehler bei der Überprüfung der Benachrichtigungen', 'error');
            }
        }
    }

    arrayBufferToBase64(buffer) {
        const bytes = new Uint8Array(buffer);
        return btoa(String.fromCharCode.apply(null, bytes));
    }

    async unsubscribeFromPush() {
        console.log('[NOTI.HTML] Starting complete unsubscription');
        
        if ('serviceWorker' in navigator) {
            // Initialize service worker first
            const registration = await navigator.serviceWorker.register('/static/service-worker.js');
            
            // Wait for activation
            if (registration.installing) {
                await new Promise(resolve => {
                    registration.installing.addEventListener('statechange', e => {
                        if (e.target.state === 'activated') resolve();
                    });
                });
            }
            
            // Get current subscription
            const subscription = await registration.pushManager.getSubscription();
            
            if (subscription) {
                // Browser-side unsubscribe
                await subscription.unsubscribe();
                console.log('[NOTI.HTML] Browser subscription removed');
            }
            
            // Server-side cleanup - now without requiring participant IDs
            await fetchWithAuth('/api/notifications/subscription', {
                method: 'DELETE',
                headers: {
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify({
                    complete_removal: true  // New flag to indicate complete removal
                })
            });
            
            console.log('[NOTI.HTML] Server-side subscriptions removed');
            return true;
        }
        return false;
    }
}

// Helper function for service worker initialization
async function initializeServiceWorker() {
    console.log('[NOTI.HTML] Starting Service Worker initialization');
    const registration = await navigator.serviceWorker.register('/static/service-worker.js');

    if (registration.installing) {
        console.log('[NOTI.HTML] Service Worker installing');
        await new Promise(resolve => {
            registration.installing.addEventListener('statechange', e => {
                if (e.target.state === 'activated') {
                    console.log('[NOTI.HTML] Service Worker activated');
                    resolve();
                }
            });
        });
    }

    return registration.active;
}

// Create instance and initialize
const notificationManager = new NotificationManager();

document.addEventListener('DOMContentLoaded', async () => {
    try {
        console.log('[NOTI.HTML] DOM Content Loaded');

        // Initialize notification manager first
        await notificationManager.init();
        console.log('[NOTI.HTML] NotificationManager initialized');

        // Validate and cleanup subscriptions if needed
        await notificationManager.validateAndCleanupSubscriptions();
        console.log('[NOTI.HTML] Validate existing subscriptions');
        
        // Load existing subscriptions
        await notificationManager.loadExistingSubscriptions();
        console.log('[NOTI.HTML] Loaded existing subscriptions');

        // Initialize status checks
        const pwaCheckElement = document.getElementById('pwaCheck');
        const notificationCheckElement = document.getElementById('notificationCheck');
        console.log('[NOTI.HTML] Status elements found:', 
            { pwaCheck: !!pwaCheckElement, notificationCheck: !!notificationCheckElement });

        // Check PWA status
        const pwaStatus = checkPWAStatus();
        updateStatusElement(
            pwaCheckElement, 
            pwaStatus.isInstalled ? 'installed' : 'notInstalled',
            'App ist installiert',
            'App muss noch installiert werden (Android) bzw. dem Home Bildschirm hinzugefügt werden (iOS)'
        );

        // Check notification permission
        const notificationPermission = await checkNotificationPermission(pwaStatus);
        updateStatusElement(
            notificationCheckElement,
            notificationPermission,
            'Benachrichtigungen sind aktiviert',
            'Benachrichtigungen müssen noch erlaubt werden'
        );

        // Add change listeners to all participant checkboxes
        document.querySelectorAll('.participant-checkbox').forEach(checkbox => {
            checkbox.addEventListener('change', () => {
                console.log('[NOTI.HTML] Checkbox changed, tracking for save');
                pendingChanges.add(parseInt(checkbox.value));
                
                // Enable save button and show pending changes
                const saveButton = document.getElementById('saveSubscriptions');
                saveButton.disabled = false;
                // showToast('Änderungen noch nicht gespeichert', 'info');
            });
        });

    } catch (error) {
        console.error('[NOTI.HTML] Initialization error:', error);
        showToast('Fehler bei der Initialisierung', 'error');
    }
});


document.getElementById('saveSubscriptions').addEventListener('click', async () => {
    if (pendingChanges.size === 0) {
        showToast('Keine Änderungen vorhanden', 'info');
        return;
    }

    try {
        const selectedIds = Array.from(document.querySelectorAll('.participant-checkbox:checked'))
            .map(cb => parseInt(cb.value));

        // New explicit handling for complete unsubscribe
        if (selectedIds.length === 0 && pendingChanges.size > 0) {
            console.log('[NOTI.HTML] Removing all subscriptions');
            await notificationManager.unsubscribeFromPush();
            showToast('Alle Benachrichtigungen deaktiviert', 'info');
        } else if (selectedIds.length > 0) {
            console.log('[NOTI.HTML] Updating subscriptions with:', selectedIds);
            await notificationManager.subscribeUserToPush(selectedIds);
            showToast('Einstellungen gespeichert', 'success');
        }

        pendingChanges.clear();
        document.getElementById('saveSubscriptions').disabled = true;

    } catch (error) {
        console.error('[NOTI.HTML] Error saving changes:', error);
        showToast('Fehler beim Speichern', 'error');
    }
});


// Check PWA status with iOS support
function checkPWAStatus() {
    // iOS detection including iPad
    const isIOSSafari = (/iphone|ipad|ipod/.test(navigator.userAgent.toLowerCase())
                         || (navigator.platform === 'MacIntel' && navigator.maxTouchPoints > 1))
                         && /apple/i.test(navigator.vendor);

    // iOS PWA detection
    const isIOSPWA = isIOSSafari && window.navigator.standalone === true;

    // Standard PWA detection
    const isStandardPWA = window.matchMedia('(display-mode: standalone)').matches;

    const status = {
        isInstalled: isIOSPWA || isStandardPWA
    };

    console.log('[PWA Status]', {
        isIOSSafari,
        isIOSPWA,
        isStandardPWA,
        finalStatus: status.isInstalled
    });

    return status;
}


function updateStatusElement(element, status, successText, failureText) {
    const iconSpan = element.querySelector('.status-icon');
    const textSpan = element.querySelector('.flex-grow-1');

    // Handle PWA installation status
    if (status === 'installed' || status === 'notInstalled') {
        iconSpan.innerHTML = status === 'installed' 
            ? '<i class="fas fa-check-circle text-success"></i>'
            : '<i class="fas fa-exclamation-circle text-warning"></i>';
        textSpan.textContent = status === 'installed' ? successText : failureText;
        return;
    }

    // Handle notification permission status
    switch(status) {
        case 'needsInstall':
            iconSpan.innerHTML = '<i class="fas fa-exclamation-circle text-warning"></i>';
            textSpan.textContent = 'App muss dem Home-Bildschirm hinzugefügt werden';
            break;
        case 'unsupported':
            iconSpan.innerHTML = '<i class="fas fa-times-circle text-danger"></i>';
            textSpan.textContent = 'Benachrichtigungen werden nicht unterstützt';
            break;
        case 'granted':
            iconSpan.innerHTML = '<i class="fas fa-check-circle text-success"></i>';
            textSpan.textContent = successText;
            break;
        default:
            iconSpan.innerHTML = '<i class="fas fa-exclamation-circle text-warning"></i>';
            textSpan.textContent = failureText;
    }
}

async function checkNotificationPermission() {
    // First check if we're in iOS standalone mode
    const isIOSPWA = window.navigator.standalone;
    const isIOSSafari = /iphone|ipad|ipod/.test(navigator.userAgent.toLowerCase()) 
                       && !window.MSStream;

    console.log('[NOTI.HTML] Permission Check Environment:', {
        isIOSPWA,
        isIOSSafari,
        hasNotificationAPI: 'Notification' in window
    });

    // If on iOS but not installed as PWA, return 'needsInstall'
    if (isIOSSafari && !isIOSPWA) {
        return 'needsInstall';
    }

    // Standard permission check
    if (!('Notification' in window)) {
        return 'unsupported';
    }

    return Notification.permission;
}

function showToast(message, type) {
    const toast = document.getElementById('notificationToast');
    const toastIcon = document.getElementById('toastIcon');
    const bsToast = new bootstrap.Toast(toast);
    
    // Set icon and color based on type
    switch(type) {
        case 'success':
            toastIcon.className = 'fas fa-check-circle text-success me-2';
            break;
        case 'error':
            toastIcon.className = 'fas fa-exclamation-circle text-danger me-2';
            break;
        case 'info':
            toastIcon.className = 'fas fa-info-circle text-info me-2';
            break;
        default:
            toastIcon.className = 'fas fa-bell me-2';
    }
    
    // Set message
    toast.querySelector('.toast-body').textContent = message;
    
    // Show toast
    bsToast.show();
}

document.getElementById('testNotification').addEventListener('click', async () => {
    const selectedIds = Array.from(document.querySelectorAll('.participant-checkbox:checked'))
        .map(cb => parseInt(cb.value));
        
    if (selectedIds.length === 0) {
        showToast('Bitte wählen Sie mindestens einen Teilnehmer aus', 'info');
        return;
    }

    try {
        const response = await fetchWithAuth('/api/notifications/test', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json'
            },
            body: JSON.stringify({ participantIds: selectedIds })
        });

        if (response.ok) {
            showToast('Test-Benachrichtigung wurde gesendet', 'success');
        } else {
            throw new Error('Fehler beim Senden der Test-Benachrichtigung');
        }
    } catch (error) {
        showToast('Fehler beim Senden der Test-Benachrichtigung', 'error');
        console.error(error);
    }
});

document.getElementById('sendBroadcast').addEventListener('click', async () => {
    const message = document.getElementById('broadcastMessage').value.trim();
    
    if (!message) {
        showToast('Bitte geben Sie eine Nachricht ein', 'info');
        return;
    }

    try {
        const response = await fetchWithAuth('/api/notifications/broadcast', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json'
            },
            body: JSON.stringify({ message })
        });

        if (response.ok) {
            showToast('Nachricht wurde gesendet', 'success');
            document.getElementById('broadcastMessage').value = '';
        } else {
            throw new Error('Fehler beim Senden der Nachricht');
        }
    } catch (error) {
        showToast('Fehler beim Senden der Nachricht', 'error');
        console.error(error);
    }
});

</script>
{% endblock %}