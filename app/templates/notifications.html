{% extends "base.html" %}

{% block content %}
<div class="container mt-4">
    <!-- Toast -->
    <div class="toast-container position-fixed bottom-0 end-0 p-3">
        <div id="notificationToast" class="toast" role="alert" aria-live="assertive" aria-atomic="true">
            <div class="toast-header">
                <i id="toastIcon" class="fas me-2"></i>
                <strong class="me-auto">Walking Bus</strong>
                <button type="button" class="btn-close" data-bs-dismiss="toast" aria-label="Close"></button>
            </div>
            <div class="toast-body"></div>
        </div>
    </div>
    
    <!-- Info Box -->
    <div class="alert alert-info" role="alert">
        <i class="fas fa-info-circle me-2"></i>
        Wähle hier die Teilnehmer, für die Du Erinnerungen erhalten möchtest. Du wirst automatisch etwa eine Stunde vor Beginn des Walking Bus eine Erinnerung erhalten.
    </div>

    <!-- Requirements Check -->
    <div class="card mb-4">
        <div class="card-header">
            <h5 class="mb-0">Systemvoraussetzungen</h5>
        </div>
        <div class="card-body">
            <ul class="list-group">
                <li class="list-group-item d-flex align-items-center" id="pwaCheck">
                    <span class="status-icon me-2">
                        <i class="fas fa-spinner fa-spin"></i>
                    </span>
                    <span class="flex-grow-1">App Installation Status</span>
                </li>
                <li class="list-group-item d-flex align-items-center" id="notificationCheck">
                    <span class="status-icon me-2">
                        <i class="fas fa-spinner fa-spin"></i>
                    </span>
                    <span class="flex-grow-1">Berechtigung für Benachrichtigungen</span>
                </li>
            </ul>
        </div>

    <!-- Participant Selection -->
    <div class="card">
        <div class="card-header">
            <h5 class="mb-0">Teilnehmer auswählen</h5>
        </div>
            <div class="d-grid gap-2 mt-3">
                <button id="saveSubscriptions" class="btn btn-primary" disabled>
                    <i class="fas fa-save me-2"></i>Änderungen speichern
                </button>
            </div>

            <div class="card-body">
                {% if stations %}
                <!-- Debug info -->
                <div class="d-none">
                    Found {{ stations|length }} stations:
                    {% for station in stations %}
                        Station: {{ station.name }} ({{ station.participants|length }} participants)
                    {% endfor %}
                </div>
            
                <!-- Existing participant section -->
                {% for station in stations %}
                <div class="station-group mb-4">
                    <h6 class="station-name mb-3">{{ station.name }}</h6>
                    <div class="participant-list">
                        {% for participant in station.participants %}
                        <div class="form-check mb-2">
                            <input class="form-check-input participant-checkbox" 
                                type="checkbox" 
                                value="{{ participant.id }}" 
                                id="participant{{ participant.id }}">
                            <label class="form-check-label" for="participant{{ participant.id }}">
                                {{ participant.name }}
                            </label>
                        </div>
                        {% endfor %}
                    </div>
                </div>
                {% endfor %}
            {% else %}
                <div class="alert alert-info">
                    Keine Stationen oder Teilnehmer gefunden.
                </div>
            {% endif %}
           
        </div>
    </div>

    <!-- Test Notification -->
    <div class="card mt-4">
        <div class="card-header">
            <h5 class="mb-0">Test Benachrichtigungen</h5>
        </div>
        <div class="card-body">
            <p class="text-muted">Hier können Sie die Benachrichtigungen für die ausgewählten Teilnehmer testen.</p>
            <button id="testNotification" class="btn btn-secondary">
                <i class="fas fa-bell me-2"></i>Test-Benachrichtigung senden
            </button>
        </div>
    </div>

</div>


<script>
let pendingChanges = new Set(); // Track changed participant IDs

class NotificationManager {
    constructor() {
        this.vapidPublicKey = null;
    }

    async init() {
        console.log('[NOTI.HTML] Initializing NotificationManager');
        if (!('serviceWorker' in navigator) || !('PushManager' in window)) {
            throw new Error('Push notifications are not supported');
        }
        await this.getVapidKey();
    }

    async getVapidKey() {
        try {
            const response = await fetchWithAuth('/api/notifications/vapid-key');
            if (!response.ok) {
                throw new Error('Failed to fetch VAPID key');
            }
            this.vapidPublicKey = await response.text();
            console.log('[NOTI.HTML] Successfully retrieved VAPID key');
            return this.vapidPublicKey;
        } catch (error) {
            console.error('[NOTI.HTML] Error fetching VAPID key:', error);
            throw error;
        }
    }

    async checkSubscriptionStatus() {
        console.log('[NOTI] Checking subscription status');
        
        // Erst Service Worker registrieren und aktivieren
        const registration = await navigator.serviceWorker.register('/static/service-worker.js');
        
        // Auf Aktivierung warten
        if (registration.installing) {
            await new Promise(resolve => {
                registration.installing.addEventListener('statechange', e => {
                    if (e.target.state === 'activated') resolve();
                });
            });
        }
        console.log('[NOTI] Service Worker activated');
        
        // Jetzt erst Subscription prüfen
        const subscription = await registration.pushManager.getSubscription();
        this.subscriptionStatus = !!subscription;
        return this.subscriptionStatus;
    }


    async createNewSubscription() {
        console.log('[NOTI] Creating new subscription');
        
        const registration = await navigator.serviceWorker.register('/static/service-worker.js');
        
        if (registration.installing) {
            await new Promise(resolve => {
                registration.installing.addEventListener('statechange', e => {
                    if (e.target.state === 'activated') resolve();
                });
            });
        }
    
    const subscription = await registration.pushManager.subscribe({
        userVisibleOnly: true,
        applicationServerKey: this.vapidPublicKey
    });
    
    await this.saveSubscriptionToServer(subscription);
}


    async updateParticipantPreferences(participantIds) {
        await fetchWithAuth('/api/notifications/preferences', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ participantIds })
        });
    }


    async subscribeUserToPush(participantIds) {
        try {
            console.log('[NOTI.HTML] Starting subscription process');
            
            const permission = await Notification.requestPermission();
            console.log('[NOTI.HTML] Permission status:', permission);
            
            if (permission !== 'granted') {
                throw new Error('Notification permission denied');
            }

            if ('serviceWorker' in navigator) {
                console.log('[NOTI.HTML] Service Worker available');
                
                // Initialize service worker first
                const registration = await navigator.serviceWorker.register('/static/service-worker.js');
                console.log('[NOTI.HTML] Service Worker registered');
                
                // Wait for activation
                if (registration.installing) {
                    await new Promise(resolve => {
                        registration.installing.addEventListener('statechange', e => {
                            if (e.target.state === 'activated') resolve();
                        });
                    });
                }
                console.log('[NOTI.HTML] Service Worker activated');
                
                // Check for existing subscription and unsubscribe if needed
                let subscription = await registration.pushManager.getSubscription();
                if (subscription) {
                    console.log('[NOTI.HTML] Found existing subscription, unsubscribing');
                    await subscription.unsubscribe();
                }
                
                // Create new subscription
                subscription = await registration.pushManager.subscribe({
                    userVisibleOnly: true,
                    applicationServerKey: this.vapidPublicKey
                });
                console.log('[NOTI.HTML] Subscription created:', subscription);

                // Send to server
                await fetchWithAuth('/api/notifications/subscription', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        subscription: subscription,
                        participantIds: participantIds
                    })
                });
                
                return true;
            }
        } catch (error) {
            console.error('[NOTI.HTML] Error:', error);
            throw error;
        }
    }


    async loadExistingSubscriptions() {
        console.log('[NOTI.HTML] Loading existing subscriptions');
        const response = await fetchWithAuth('/api/notifications/subscription');
        const data = await response.json();

        await this.checkSubscriptionStatus();
        
        if (data && data.participantIds) {
            console.log('[NOTI.HTML] Found subscriptions for:', data.participantIds);
            // Check the corresponding checkboxes
            data.participantIds.forEach(id => {
                const checkbox = document.querySelector(`#participant${id}`);
                if (checkbox) {
                    checkbox.checked = true;
                }
            });
        }
    }

    async handleParticipantChange() {
        const selectedIds = Array.from(document.querySelectorAll('.participant-checkbox:checked'))
            .map(cb => parseInt(cb.value));
        
        console.log('[NOTI.HTML] Selected participants changed:', selectedIds);
        
        if (selectedIds.length === 0) {
            // No participants selected - unsubscribe completely
            console.log('[NOTI.HTML] No participants selected, unsubscribing');
            await this.unsubscribeFromPush();
            showToast('Benachrichtigungen deaktiviert', 'info');
        } else {
            // Update subscription with new participant selection
            console.log('[NOTI.HTML] Updating subscription with new participants');
            await this.subscribeUserToPush(selectedIds);
            showToast('Einstellungen aktualisiert', 'success');
        }
    }

    async cleanupSubscription(subscription) {
        try {
            // 1. Unsubscribe from browser
            await subscription.unsubscribe();
            console.log('[NOTI.HTML] Unsubscribed from push service');
            
            // 2. Delete from backend BEFORE loading subscriptions
            await fetchWithAuth('/api/notifications/subscription', {
                method: 'DELETE',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ endpoint: subscription.endpoint })
            });
            console.log('[NOTI.HTML] Removed server subscription');
            
            // 3. Clear checkboxes
            document.querySelectorAll('.participant-checkbox').forEach(checkbox => {
                checkbox.checked = false;
            });
            
            // 4. Wait for backend cleanup to complete before proceeding
            await new Promise(resolve => setTimeout(resolve, 100));
            
            showToast('Benachrichtigungen wurden zurückgesetzt', 'info');
        } catch (error) {
            console.error('[NOTI.HTML] Cleanup error:', error);
        }
    }

    async validateAndCleanupSubscriptions() {
        console.log('[NOTI.HTML] Validating existing subscriptions');
        
        if (!this.vapidPublicKey) {
            await this.getVapidKey();
        }
        
        if ('serviceWorker' in navigator) {
            try {
                const registration = await navigator.serviceWorker.register('/static/service-worker.js');
                
                if (registration.installing) {
                    await new Promise(resolve => {
                        registration.installing.addEventListener('statechange', e => {
                            if (e.target.state === 'activated') resolve();
                        });
                    });
                }
                console.log('[NOTI.HTML] Service Worker activated');
                
                const subscription = await registration.pushManager.getSubscription();
                
                if (subscription) {
                    // Convert current key to URL-safe base64
                    const currentKey = this.arrayBufferToBase64(subscription.options.applicationServerKey)
                        .replace(/=/g, '')
                        .replace(/\+/g, '-')
                        .replace(/\//g, '_');
                    
                    console.log('[NOTI.HTML] Current key:', currentKey);
                    console.log('[NOTI.HTML] New key:', this.vapidPublicKey);
                    
                    if (currentKey !== this.vapidPublicKey) {
                        console.log('[NOTI.HTML] VAPID key mismatch - cleaning up');
                        await this.cleanupSubscription(subscription);
                    } else {
                        console.log('[NOTI.HTML] VAPID keys match');
                    }
                }
            } catch (error) {
                console.error('[NOTI.HTML] Validation error:', error);
                showToast('Fehler bei der Überprüfung der Benachrichtigungen', 'error');
            }
        }
    }

    arrayBufferToBase64(buffer) {
        const bytes = new Uint8Array(buffer);
        return btoa(String.fromCharCode.apply(null, bytes));
    }

    async unsubscribeFromPush() {
        console.log('[NOTI.HTML] Starting complete unsubscription');
        
        if ('serviceWorker' in navigator) {
            // Initialize service worker first
            const registration = await navigator.serviceWorker.register('/static/service-worker.js');
            
            // Wait for activation
            if (registration.installing) {
                await new Promise(resolve => {
                    registration.installing.addEventListener('statechange', e => {
                        if (e.target.state === 'activated') resolve();
                    });
                });
            }
            
            // Get current subscription
            const subscription = await registration.pushManager.getSubscription();
            
            if (subscription) {
                // Browser-side unsubscribe
                await subscription.unsubscribe();
                console.log('[NOTI.HTML] Browser subscription removed');
            }
            
            // Server-side cleanup - now without requiring participant IDs
            await fetchWithAuth('/api/notifications/subscription', {
                method: 'DELETE',
                headers: {
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify({
                    complete_removal: true  // New flag to indicate complete removal
                })
            });
            
            console.log('[NOTI.HTML] Server-side subscriptions removed');
            return true;
        }
        return false;
    }
}

// Helper function for service worker initialization
async function initializeServiceWorker() {
    console.log('[NOTI.HTML] Starting Service Worker initialization');
    const registration = await navigator.serviceWorker.register('/static/service-worker.js');

    if (registration.installing) {
        console.log('[NOTI.HTML] Service Worker installing');
        await new Promise(resolve => {
            registration.installing.addEventListener('statechange', e => {
                if (e.target.state === 'activated') {
                    console.log('[NOTI.HTML] Service Worker activated');
                    resolve();
                }
            });
        });
    }

    return registration.active;
}

// Create instance and initialize
const notificationManager = new NotificationManager();

document.addEventListener('DOMContentLoaded', async () => {
    try {
        console.log('[NOTI.HTML] DOM Content Loaded');

        // Check PWA status first
        const pwaStatus = checkPWAStatus();
        const pwaCheckElement = document.getElementById('pwaCheck');
        
        // Update PWA status UI first
        updateStatusElement(
            pwaCheckElement,
            pwaStatus.isInstalled ? 'installed' : 'notInstalled',
            'App ist installiert',
            'App muss noch installiert werden (Android) bzw. dem Home Bildschirm hinzugefügt werden (iOS)'
        );

        // Only proceed with notification setup if installed
        if (pwaStatus.isInstalled) {
            await notificationManager.init();
            await notificationManager.validateAndCleanupSubscriptions();
            await notificationManager.loadExistingSubscriptions();

            const notificationCheckElement = document.getElementById('notificationCheck');
            const notificationPermission = await checkNotificationPermission(pwaStatus);
            
            updateStatusElement(
                notificationCheckElement,
                notificationPermission,
                'Berechtigung für Benachrichtigungen wurde erteilt.',
                'Berechtigung für Benachrichtigungen muss noch erteilt werden.'
            );

            // Setup checkbox listeners only when installed
            setupCheckboxListeners();
        } else {
            // Skip notification initialization for non-installed apps
            const notificationCheckElement = document.getElementById('notificationCheck');
            updateStatusElement(
                notificationCheckElement,
                'needsInstall',
                '',
                'Installation erforderlich für Benachrichtigungen'
            );
        }

    } catch (error) {
        console.error('[NOTI.HTML] Initialization error:', error);
        showToast('Fehler bei der Initialisierung', 'error');
    }
});

// Move checkbox setup to separate function
function setupCheckboxListeners() {
    document.querySelectorAll('.participant-checkbox').forEach(checkbox => {
        checkbox.addEventListener('change', () => {
            console.log('[NOTI.HTML] Checkbox changed, tracking for save');
            pendingChanges.add(parseInt(checkbox.value));
            document.getElementById('saveSubscriptions').disabled = false;
        });
    });
}



document.getElementById('saveSubscriptions').addEventListener('click', async () => {
    if (pendingChanges.size === 0) {
        showToast('Keine Änderungen vorhanden', 'info');
        return;
    }

    try {
        const selectedIds = Array.from(document.querySelectorAll('.participant-checkbox:checked'))
            .map(cb => parseInt(cb.value));

        // Check notification permission first
        if (Notification.permission === 'denied') {
            showToast('Benachrichtigungen sind blockiert. Bitte erlauben Sie Benachrichtigungen in Ihren Browser-Einstellungen.', 'error');
            return;
        }

        if (selectedIds.length === 0 && pendingChanges.size > 0) {
            console.log('[NOTI.HTML] Removing all subscriptions');
            await notificationManager.unsubscribeFromPush();
            showToast('Alle Benachrichtigungen deaktiviert', 'info');
        } else if (selectedIds.length > 0) {
            console.log('[NOTI.HTML] Updating subscriptions with:', selectedIds);
            await notificationManager.subscribeUserToPush(selectedIds);
            showToast('Einstellungen gespeichert', 'success');
        }

        pendingChanges.clear();
        document.getElementById('saveSubscriptions').disabled = true;

    } catch (error) {
        console.error('[NOTI.HTML] Error saving changes:', error);
        showToast('Fehler beim Speichern', 'error');
    }
});


// Check PWA status with iOS support
function checkPWAStatus() {
    try {
        // iOS standalone mode check
        if (navigator.standalone) {
            return { isInstalled: true };
        }
        
        // Android/Desktop PWA check
        if (window.matchMedia('(display-mode: standalone)').matches) {
            return { isInstalled: true };
        }

        // Safari on iOS check
        if (window.navigator.userAgent.includes('Safari') && 
            window.navigator.userAgent.includes('iPhone')) {
            if (window.navigator.standalone === true) {
                return { isInstalled: true };
            }
        }
        
        return { isInstalled: false };
        
    } catch (error) {
        // Log for debugging but don't break the app
        console.log('[PWA-CHECK] Status check failed:', error);
        // Fallback to not installed as safe default
        return { isInstalled: false };
    }
}


function updateStatusElement(element, status, successText, failureText) {
    const iconSpan = element.querySelector('.status-icon');
    const textSpan = element.querySelector('.flex-grow-1');

    // Log the incoming status for debugging
    if (status === 'installed' || status === 'notInstalled') {
        console.log('[PERMISSIONS] PWA status check:', status);
    } else {
        console.log('[PERMISSIONS] Notification status check:', status);
        console.log('[PERMISSIONS] System notification permission:', Notification.permission);
    }

    // Handle PWA installation status first
    if (status === 'installed' || status === 'notInstalled') {
        iconSpan.innerHTML = status === 'installed' 
            ? '<i class="fas fa-check-circle text-success"></i>'
            : '<i class="fas fa-exclamation-circle text-warning"></i>';
        textSpan.textContent = status === 'installed' ? successText : failureText;
        return;
    }

    // Handle notification permission status
    switch(status) {
        case 'needsInstall':
            iconSpan.innerHTML = '<i class="fas fa-exclamation-circle text-warning"></i>';
            textSpan.textContent = 'Bitte erst installieren.';
            break;
            
        case 'unsupported':
            iconSpan.innerHTML = '<i class="fas fa-times-circle text-danger"></i>';
            textSpan.textContent = 'Benachrichtigungen werden nicht unterstützt';
            break;
            
        case 'granted':
            iconSpan.innerHTML = '<i class="fas fa-check-circle text-success"></i>';
            textSpan.textContent = successText;
            break;
            
        case 'denied':
            iconSpan.innerHTML = '<i class="fas fa-times-circle text-warning"></i>';
            textSpan.innerHTML = `
            <div class="text-danger mb-3">Benachrichtigungen wurden blockiert. Die Einstellung muss manuell wie folgt geändert werden:</div>
            
            <div class="platform-instructions">
                <div class="platform mb-3">
                    <h6 class="fw-bold">iOS</h6>
                    <div class="ms-3">
                        Einstellungen > Datenschutz & Sicherheit > WalkBus
                    </div>
                </div>
                
                <div class="platform">
                    <h6 class="fw-bold">Android</h6>
                    <div class="ms-3">
                        Einstellungen > Apps > WalkBus > Berechtigungen
                    </div>
                </div>
            </div>`;
        break;
            
        default:
            iconSpan.innerHTML = '<i class="fas fa-exclamation-circle text-warning"></i>';
            textSpan.innerHTML = 'Berechtigung fehlt. Wähle unten einen Teilnehmer, klicke "Änderungen speichern" und erlaube in der folgenden Abfrage die Benachrichtigungen.';
    }
}


function checkNotificationPermission() {
    // First check if PWA is installed
    if (!checkPWAStatus().isInstalled) {
        return 'needsInstall';
    }

    // Check if notifications are supported
    if (!('Notification' in window)) {
        return 'unsupported';
    }

    // Return actual permission status
    return Notification.permission; // returns 'granted', 'denied' or 'default'
}

function showToast(message, type) {
    const toast = document.getElementById('notificationToast');
    const toastIcon = document.getElementById('toastIcon');
    const bsToast = new bootstrap.Toast(toast);
    
    // Set icon and color based on type
    switch(type) {
        case 'success':
            toastIcon.className = 'fas fa-check-circle text-success me-2';
            break;
        case 'error':
            toastIcon.className = 'fas fa-exclamation-circle text-danger me-2';
            break;
        case 'info':
            toastIcon.className = 'fas fa-info-circle text-info me-2';
            break;
        default:
            toastIcon.className = 'fas fa-bell me-2';
    }
    
    // Set message
    toast.querySelector('.toast-body').textContent = message;
    
    // Show toast
    bsToast.show();
}

document.getElementById('testNotification').addEventListener('click', async () => {
    const selectedIds = Array.from(document.querySelectorAll('.participant-checkbox:checked'))
        .map(cb => parseInt(cb.value));
        
    if (selectedIds.length === 0) {
        showToast('Bitte wählen Sie mindestens einen Teilnehmer aus', 'info');
        return;
    }

    try {
        const response = await fetchWithAuth('/api/notifications/test', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json'
            },
            body: JSON.stringify({ participantIds: selectedIds })
        });

        if (response.ok) {
            showToast('Test-Benachrichtigung wurde gesendet', 'success');
        } else {
            throw new Error('Fehler beim Senden der Test-Benachrichtigung');
        }
    } catch (error) {
        showToast('Fehler beim Senden der Test-Benachrichtigung', 'error');
        console.error(error);
    }
});


</script>
{% endblock %}