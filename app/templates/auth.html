<!-- auth.html -->
<script>
(function() {
    window.TokenManager = class TokenManager {
        constructor() {
            this.AUTH_URL = `${window.location.origin}/static/auth-token`;
            console.log('[AUTH.HTML][TokenManager] Initializing with URL:', this.AUTH_URL);
        }

        async storeToken(token) {
            console.log('[AUTH.HTML][TokenManager] Storing token');
            
            if ('caches' in window) {
                const cache = await caches.open('walking-bus-auth-v1');
                const tokenBlob = new Blob(
                    [JSON.stringify({
                        token,
                        timestamp: Date.now(),
                        expiresAt: Date.now() + (30 * 24 * 60 * 60 * 1000)
                    })],
                    { type: 'application/json' }
                );
                await cache.put(this.AUTH_URL, new Response(tokenBlob));
                console.log('[AUTH.HTML][TokenManager] Token stored in Cache Storage');
            }

            // Backup in localStorage
            localStorage.setItem('auth_token', token);
        }

        async getToken() {
            console.log('[AUTH.HTML][TokenManager] Retrieving token');

            if ('caches' in window) {
                try {
                    const cache = await caches.open('walking-bus-auth-v1');
                    const response = await cache.match(this.AUTH_URL);
                    
                    if (response) {
                        const data = await response.json();
                        console.log('[AUTH.HTML][TokenManager] Token found in Cache Storage');
                        return data.token;
                    }
                } catch (error) {
                    console.log('[AUTH.HTML][TokenManager] Cache Storage access failed:', error);
                }
            }

            // Fallback to localStorage
            return localStorage.getItem('auth_token');
        }

        async clearToken() {
            console.log('[AUTH.HTML][TokenManager] Clearing token');

            if ('caches' in window) {
                const cache = await caches.open('walking-bus-auth-v1');
                await cache.delete(this.AUTH_URL);
            }

            localStorage.removeItem('auth_token');
            document.cookie = 'session=; expires=Thu, 01 Jan 1970 00:00:00 UTC; path=/; SameSite=Strict';
        }
    }
    // Globale Instanz erstellen
    window.tokenManager = new TokenManager();
    console.log('[AUTH.HTML] TokenManager instance created globally');

    window.authReady = Promise.resolve(window.tokenManager);
    
    // Make fetchWithAuth wait for auth to be ready
    const originalFetchWithAuth = window.fetchWithAuth;
    window.fetchWithAuth = async function(...args) {
        await window.authReady;
        return originalFetchWithAuth.apply(this, args);
    }
    
    console.log('[AUTH.HTML] TokenManager initialized and ready for use');
})();


(function() {
    // Make auth functions globally available
    window.fetchWithAuth = async function(url, options = {}) {
        try {
            const token = await tokenManager.getToken();
            if (!token) {
                window.location.href = '/login';
                return;
            }
            
            const response = await fetch(url, {
                ...options,
                headers: {
                    ...options.headers,
                    'Authorization': `Bearer ${token}`
                }
            });

            // Add this check
            if (response.status === 401) {
                await tokenManager.clearToken();
                window.location.href = '/login';
                return;
            }

            return response;
        } catch (error) {
            throw error;
        }
    };

    // Initialize Axios interceptor
    axios.interceptors.request.use(async (config) => {
        console.log(`[AUTH.HTML] Intercepting ${config.method?.toUpperCase()} request to: ${config.url}`);
        
        const token = await tokenManager.getToken();
        
        if (token) {
            config.headers['Authorization'] = `Bearer ${token}`;
        }
        
        return config;
    }, (error) => {
        return Promise.reject(error);
    });


    axios.interceptors.response.use(
        async response => {
            const newToken = response.data.new_auth_token;
            if (newToken) {
                await tokenManager.storeToken(newToken);
            }
            return response;
        },
        error => {
            if (error.response?.status === 401) {
                if (error.response?.data?.code === 'PASSWORD_CHANGED') {
                    console.log('[AUTH.HTML] Password changed, clearing all tokens');
                } else {
                    console.log('[AUTH.HTML] Received 401, clearing tokens and redirecting to login');
                }
                
                tokenManager.clearToken();
                window.location.href = '/login';
            }
            return Promise.reject(error);
        }
    );
})();


async function loginUser() {
    const form = document.getElementById('loginForm');
    if (!form) {
        console.log('[AUTH.HTML] Login form not found, exiting loginUser function.');
        return;
    }

    form.addEventListener('submit', async (event) => {
        event.preventDefault();
        console.log('[AUTH.HTML] Form submission prevented, preparing to send login request.');

        const formData = new FormData(form);

        try {
            const response = await fetch('/login', {
                method: 'POST',
                body: formData,
                headers: {
                    'Accept': 'application/json',
                    'X-Requested-With': 'XMLHttpRequest'
                }
            });

            const data = await response.json();
            console.log('[AUTH.HTML] Response received:', data);

            if (!data.success) {
                // Update bus selection if needed
                if (data.buses) {
                    const select = form.querySelector('select[name="walking_bus"]');
                    if (select) {
                        select.innerHTML = data.buses.map(bus =>
                            `<option value="${bus.id}" ${bus.id == data.selected_bus_id ? 'selected' : ''}>${bus.name}</option>`
                        ).join('');
                    }
                }

                // Show error message
                showErrorMessage(form, data.error);
                return;
            }

            // Handle successful login
            const { auth_token: authToken, redirect_url: redirectUrl } = data;

            if (authToken) {
                console.log('[AUTH.HTML] Processing auth token');
                await tokenManager.storeToken(authToken);
                window.location.replace(redirectUrl);
            }
        } catch (error) {
            console.error('[AUTH.HTML] Login error:', error);
            showErrorMessage(form, 'Ein unerwarteter Fehler ist aufgetreten. Bitte versuchen Sie es erneut.');
        }
    });
}

// Helper function for error display
function showErrorMessage(form, message) {
    const errorDiv = document.querySelector('.alert-danger') || 
                    document.createElement('div');
    errorDiv.className = 'alert alert-danger';
    errorDiv.textContent = message;
    
    const formContainer = form.parentNode;
    const existingError = formContainer.querySelector('.alert-danger');
    if (existingError) {
        formContainer.removeChild(existingError);
    }
    formContainer.insertBefore(errorDiv, form);
}

// Add this at the end of the auth.html script section
window.handleLogout = async function() {
    try {
        const token = await tokenManager.getToken();
        await tokenManager.clearToken();
        
        // Server-side invalidation
        await fetch('/logout', {
            headers: token ? {
                'Authorization': `Bearer ${token}`
            } : {}
        });
        
        window.location.href = '/login';
    } catch (error) {
        console.error('[AUTH.HTML][LOGOUT] Error during logout:', error);
        window.location.href = '/login';
    }
}


navigator.serviceWorker.addEventListener('message', async (event) => {
    if (event.data.type === 'AUTH_ERROR' && event.data.status === 401) {
        await tokenManager.clearToken();
        window.location.href = '/login';
    }
});

</script>