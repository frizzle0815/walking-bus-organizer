<!-- auth.html -->
<script>
(function() {
    window.TokenManager = class TokenManager {
        constructor() {
            this.DB_CONFIG = {
                name: 'WalkingBusAuth',
                version: 1,
                store: 'tokens'
            };
            this.initializeDB();
        }

        async _initializeServiceWorker() {
            console.log('[AUTH.HTML][TokenManager] Starting Service Worker initialization');
            const registration = await navigator.serviceWorker.register('/static/service-worker.js');

            if (registration.installing) {
                console.log('[AUTH.HTML][TokenManager] Service Worker installing');
                await new Promise(resolve => {
                    registration.installing.addEventListener('statechange', e => {
                        if (e.target.state === 'activated') {
                            console.log('[AUTH.HTML][TokenManager] Service Worker activated');
                            resolve();
                        }
                    });
                });
            }

            return registration.active;
        }

        async initializeDB() {
            const request = indexedDB.open(this.DB_CONFIG.name, this.DB_CONFIG.version);
            
            request.onupgradeneeded = (event) => {
                const db = event.target.result;
                if (!db.objectStoreNames.contains(this.DB_CONFIG.store)) {
                    db.createObjectStore(this.DB_CONFIG.store);
                }
            };
            
            return new Promise((resolve, reject) => {
                request.onsuccess = () => resolve(request.result);
                request.onerror = () => reject(request.error);
            });
        }

        async storeToken(token) {
            const tokenData = {
                token,
                timestamp: Date.now(),
                expiresAt: Date.now() + (30 * 24 * 60 * 60 * 1000)
            };

            // Store in IndexedDB
            const db = await this.initializeDB();
            const tx = db.transaction(this.DB_CONFIG.store, 'readwrite');
            await tx.objectStore(this.DB_CONFIG.store).put(tokenData, 'current-token');

            // Store in localStorage
            localStorage.setItem('auth_token', token);

            // Store in ServiceWorker
            if ('serviceWorker' in navigator) {
                const activeWorker = await this._initializeServiceWorker();
                await this._storeInServiceWorker(activeWorker, token);
            }
        }

        async getToken() {
            try {
                // Check IndexedDB first
                const indexedDBToken = await this._getFromIndexedDB();
                if (indexedDBToken) {
                    await this.synchronizeToken(indexedDBToken);
                    return indexedDBToken;
                }

                // Then check localStorage (synchronous and fast)
                const localStorageToken = this._getFromLocalStorage();
                if (localStorageToken) {
                    await this.synchronizeToken(localStorageToken);
                    return localStorageToken;
                }

                // Finally check ServiceWorker
                const serviceWorkerToken = await this._getFromServiceWorker();
                if (serviceWorkerToken) {
                    await this.synchronizeToken(serviceWorkerToken);
                    return serviceWorkerToken;
                }

                return null;
            } catch (error) {
                console.log('[AUTH.HTML][TokenManager] Error retrieving token:', error);
                return null;
            }
        }

        async synchronizeToken(token) {
            try {
                const db = await this.initializeDB();
                const tx = db.transaction(this.DB_CONFIG.store, 'readonly');
                const store = tx.objectStore(this.DB_CONFIG.store);
                const indexedDBToken = await store.get('current-token');

                if (!indexedDBToken?.token) {
                    await this.storeToken(token);
                }

                if (!localStorage.getItem('auth_token')) {
                    localStorage.setItem('auth_token', token);
                }

                if ('serviceWorker' in navigator) {
                    const activeWorker = await this._initializeServiceWorker();
                    const swToken = await this._getFromServiceWorker(activeWorker);
                    if (!swToken) {
                        await this._storeInServiceWorker(activeWorker, token);
                    }
                }
            } catch (error) {
                console.error('[AUTH.HTML][TokenManager] Sync error:', error);
            }
        }

        async clearToken() {
            // Clear IndexedDB
            const db = await this.initializeDB();
            const tx = db.transaction(this.DB_CONFIG.store, 'readwrite');
            await tx.objectStore(this.DB_CONFIG.store).clear();

            // Clear localStorage
            localStorage.removeItem('auth_token');

            // Clear Flask session cookie
            document.cookie = 'session=; expires=Thu, 01 Jan 1970 00:00:00 UTC; path=/; SameSite=Strict';

            // Clear ServiceWorker with initialization
            if ('serviceWorker' in navigator) {
                const activeWorker = await this._initializeServiceWorker();
                const messageChannel = new MessageChannel();
                activeWorker.postMessage({
                    type: 'CLEAR_AUTH_TOKEN'
                }, [messageChannel.port2]);
            }
        }

        async _storeInServiceWorker(activeWorker, token) {
            return new Promise((resolve) => {
                const messageChannel = new MessageChannel();
                messageChannel.port1.onmessage = (event) => resolve(event.data);
                activeWorker.postMessage({
                    type: 'STORE_AUTH_TOKEN',
                    token: token
                }, [messageChannel.port2]);
            });
        }

        async _getFromIndexedDB() {
            const db = await this.initializeDB();
            const tx = db.transaction(this.DB_CONFIG.store, 'readonly');
            const tokenData = await tx.objectStore(this.DB_CONFIG.store).get('current-token');
            return tokenData?.token;
        }

        _getFromLocalStorage() {
            return localStorage.getItem('auth_token');
        }

        async _getFromServiceWorker(activeWorker = null) {
            if (!('serviceWorker' in navigator)) return null;
            
            const worker = activeWorker || await this._initializeServiceWorker();
            const messageChannel = new MessageChannel();
            
            return new Promise((resolve) => {
                messageChannel.port1.onmessage = (event) => resolve(event.data?.token);
                worker.postMessage({
                    type: 'GET_AUTH_TOKEN'
                }, [messageChannel.port2]);
            });
        }
    }
    // Globale Instanz erstellen
    window.tokenManager = new TokenManager();
    console.log('[AUTH.HTML] TokenManager instance created globally');

    window.authReady = Promise.resolve(window.tokenManager);
    
    // Make fetchWithAuth wait for auth to be ready
    const originalFetchWithAuth = window.fetchWithAuth;
    window.fetchWithAuth = async function(...args) {
        await window.authReady;
        return originalFetchWithAuth.apply(this, args);
    }
    
    console.log('[AUTH.HTML] TokenManager initialized and ready for use');
})();


(function() {
    // Make auth functions globally available
    window.fetchWithAuth = async function(url, options = {}) {
        try {
            const token = await tokenManager.getToken();
            if (!token) {
                window.location.href = '/login';
                return;
            }
            
            const response = await fetch(url, {
                ...options,
                headers: {
                    ...options.headers,
                    'Authorization': `Bearer ${token}`
                }
            });

            // Add this check
            if (response.status === 401) {
                await tokenManager.clearToken();
                window.location.href = '/login';
                return;
            }

            return response;
        } catch (error) {
            throw error;
        }
    };

    // Initialize Axios interceptor
    axios.interceptors.request.use(async (config) => {
        console.log(`[AUTH.HTML] Intercepting ${config.method?.toUpperCase()} request to: ${config.url}`);
        
        const token = await tokenManager.getToken();
        
        if (token) {
            config.headers['Authorization'] = `Bearer ${token}`;
        }
        
        return config;
    }, (error) => {
        return Promise.reject(error);
    });


    axios.interceptors.response.use(
        async response => {
            const newToken = response.data.new_auth_token;
            if (newToken) {
                await tokenManager.storeToken(newToken);
            }
            return response;
        },
        error => {
            if (error.response?.status === 401) {
                if (error.response?.data?.code === 'PASSWORD_CHANGED') {
                    console.log('[AUTH.HTML] Password changed, clearing all tokens');
                } else {
                    console.log('[AUTH.HTML] Received 401, clearing tokens and redirecting to login');
                }
                
                tokenManager.clearToken();
                window.location.href = '/login';
            }
            return Promise.reject(error);
        }
    );
})();


async function loginUser() {
    const form = document.getElementById('loginForm');
    if (!form) {
        console.log('[AUTH.HTML] Login form not found, exiting loginUser function.');
        return;
    }

    form.addEventListener('submit', async (event) => {
        event.preventDefault();
        console.log('[AUTH.HTML] Form submission prevented, preparing to send login request.');

        const formData = new FormData(form);

        try {
            const response = await fetch('/login', {
                method: 'POST',
                body: formData,
                headers: {
                    'Accept': 'application/json',
                    'X-Requested-With': 'XMLHttpRequest'
                }
            });

            const data = await response.json();
            console.log('[AUTH.HTML] Response received:', data);

            if (!data.success) {
                // Update bus selection if needed
                if (data.buses) {
                    const select = form.querySelector('select[name="walking_bus"]');
                    if (select) {
                        select.innerHTML = data.buses.map(bus =>
                            `<option value="${bus.id}" ${bus.id == data.selected_bus_id ? 'selected' : ''}>${bus.name}</option>`
                        ).join('');
                    }
                }

                // Show error message
                showErrorMessage(form, data.error);
                return;
            }

            // Handle successful login
            const { auth_token: authToken, redirect_url: redirectUrl } = data;

            if (authToken) {
                console.log('[AUTH.HTML] Processing auth token');
                await tokenManager.storeToken(authToken);
                window.location.replace(redirectUrl);
            }
        } catch (error) {
            console.error('[AUTH.HTML] Login error:', error);
            showErrorMessage(form, 'Ein unerwarteter Fehler ist aufgetreten. Bitte versuchen Sie es erneut.');
        }
    });
}

// Helper function for error display
function showErrorMessage(form, message) {
    const errorDiv = document.querySelector('.alert-danger') || 
                    document.createElement('div');
    errorDiv.className = 'alert alert-danger';
    errorDiv.textContent = message;
    
    const formContainer = form.parentNode;
    const existingError = formContainer.querySelector('.alert-danger');
    if (existingError) {
        formContainer.removeChild(existingError);
    }
    formContainer.insertBefore(errorDiv, form);
}

// Add this at the end of the auth.html script section
window.handleLogout = async function() {
    try {
        const token = await tokenManager.getToken();
        await tokenManager.clearToken();
        
        // Server-side invalidation
        await fetch('/logout', {
            headers: token ? {
                'Authorization': `Bearer ${token}`
            } : {}
        });
        
        window.location.href = '/login';
    } catch (error) {
        console.error('[AUTH.HTML][LOGOUT] Error during logout:', error);
        window.location.href = '/login';
    }
}


navigator.serviceWorker.addEventListener('message', async (event) => {
    if (event.data.type === 'AUTH_ERROR' && event.data.status === 401) {
        await tokenManager.clearToken();
        window.location.href = '/login';
    }
});

</script>