<!-- auth.html -->
<script>
(function() {
    // Make auth functions globally available
    window.fetchWithAuth = async function(url, options = {}) {
        console.log('[AUTH.HTML][FETCH] Starting authenticated request to:', url);
        
        try {
            let token = null;
            const isIOS = /iPad|iPhone|iPod/.test(navigator.userAgent);
            
            if (isIOS) {
                // iOS path: use localStorage
                console.log('[AUTH.HTML][FETCH] iOS detected, using localStorage');
                token = localStorage.getItem('auth_token');
            } else {
                // Standard path: use cache
                const cache = await caches.open('walking-bus-auth-v1');
                const tokenResponse = await cache.match('static/auth-token');
                
                if (tokenResponse) {
                    const tokenData = await tokenResponse.json();
                    token = tokenData.token;
                }
            }
            
            if (!token) {
                console.log('[AUTH.HTML][FETCH] No token found');
                window.location.href = '/login';
                return;
            }
            
            console.log('[AUTH.HTML][FETCH] Token retrieved successfully');
            
            options.headers = {
                ...options.headers,
                'Authorization': `Bearer ${token}`
            };
            
            console.log('[AUTH.HTML][FETCH] Sending request with auth header');
            return fetch(url, options);
        } catch (error) {
            console.error('[AUTH.HTML][FETCH] Error during authenticated request:', error);
            throw error;
        }
    };

    window.getAuthToken = async function() {
        console.log('[AUTH.HTML] Attempting to retrieve auth token...');
        
        const isIOS = /iPad|iPhone|iPod/.test(navigator.userAgent);
        
        if (isIOS) {
            // iOS path
            const token = localStorage.getItem('auth_token');
            if (token) {
                console.log('[AUTH.HTML] Successfully retrieved auth token from localStorage');
                return token;
            }
        } else if ('caches' in window) {
            // Standard path
            try {
                const cache = await caches.open('walking-bus-auth-v1');
                const response = await cache.match('static/auth-token');
                if (response) {
                    const data = await response.json();
                    console.log('[AUTH.HTML] Successfully retrieved auth token from cache');
                    return data.token;
                }
            } catch (error) {
                console.error('[AUTH.HTML] Error accessing cache:', error);
            }
        }
        
        return null;
    };

    // Initialize Axios interceptor
    axios.interceptors.request.use(async (config) => {
        console.log(`[AUTH.HTML] Intercepting ${config.method?.toUpperCase()} request to: ${config.url}`);
        
        // Try Service Worker first
        let token = await window.getAuthToken();
        
        // Fallback to localStorage for iOS
        if (!token && /iPad|iPhone|iPod/.test(navigator.userAgent)) {
            token = localStorage.getItem('auth_token');
        }
        
        if (token) {
            config.headers['Authorization'] = `Bearer ${token}`;
        }
        return config;
    }, (error) => {
        console.error('[AUTH.HTML] Error in request interceptor:', error);
        return Promise.reject(error);
    });

    // Der Token wird über die route initialize-daily-status geprüft und die hier definierte Aktualisierung durchgeführt
    // wenn die Restlaufzeit zu gering ist
    axios.interceptors.response.use(
        async response => {
            const newToken = response.data.new_auth_token;
            if (newToken && 'serviceWorker' in navigator) {
                console.log('[AUTH.HTML] New auth token received, preparing to update');
                
                try {
                    // Initialize Service Worker first
                    const activeWorker = await initializeServiceWorker();  // Token storage doesn't work without this - don't know why!
                    console.log('[AUTH.HTML] Service Worker initialized for token update');

                    await new Promise((resolve, reject) => {
                        const messageChannel = new MessageChannel();
                        const timeoutId = setTimeout(() => {
                            console.log('[AUTH.HTML] Token update timeout reached');
                            reject(new Error('Token update timeout'));
                        }, 5000);
                        
                        messageChannel.port1.onmessage = (event) => {
                            clearTimeout(timeoutId);
                            if (event.data.success) {
                                console.log('[AUTH.HTML] Token successfully updated in service worker');
                                resolve();
                            } else {
                                console.error('[AUTH.HTML] Failed to update token in service worker');
                                reject(new Error('Failed to update token'));
                            }
                        };

                        console.log('[AUTH.HTML] Sending new token to service worker');
                        activeWorker.postMessage({
                            type: 'STORE_AUTH_TOKEN',
                            token: newToken
                        }, [messageChannel.port2]);
                    });
                } catch (error) {
                    console.error('[AUTH.HTML] Error during service worker initialization:', error);
                }
            }
            return response;
        },
        error => {
            if (error.response?.status === 401) {
                console.log('[AUTH.HTML] Received 401, redirecting to login');
                window.location.href = '/login';
            }
            return Promise.reject(error);
        }
    );
})();


 //Make sure, we use the correct service worker
 async function initializeServiceWorker() {
     console.log('[AUTH.HTML]Starting Service Worker initialization');
     const registration = await navigator.serviceWorker.register('/static/service-worker.js');

     if (registration.installing) {
         console.log('[AUTH.HTML]Service Worker installing');
         await new Promise(resolve => {
             registration.installing.addEventListener('statechange', e => {
                 if (e.target.state === 'activated') {
                     console.log('[AUTH.HTML]Service Worker activated');
                     resolve();
                 }
             });
         });
     }

     return registration.active;
 }

 async function loginUser() {
     const form = document.getElementById('loginForm');
     if (!form) {
         console.log('[AUTH.HTML]Login form not found, exiting loginUser function.');
         return;
     }

     form.addEventListener('submit', async (event) => {
         event.preventDefault();
         console.log('[AUTH.HTML]Form submission prevented, preparing to send login request.');

         const formData = new FormData(form);

         try {
             // Add iOS detection
             const isIOS = /iPad|iPhone|iPod/.test(navigator.userAgent);
             console.log('[AUTH.HTML]Device is iOS:', isIOS);

             const response = await fetch('/login', {
                 method: 'POST',
                 body: formData,
                 // Add specific headers for iOS
                 headers: {
                     'Accept': 'application/json',
                     'X-Requested-With': 'XMLHttpRequest'
                 }
             });

             if (!response.ok) {
                 console.error('[AUTH.HTML]Login failed:', response.status, response.statusText);
                 const errorText = await response.text();
                 console.error('[AUTH.HTML]Error details:', errorText);
                 document.body.innerHTML = errorText;
                 return;
             }

             const data = await response.json();
             console.log('[AUTH.HTML]Response received:', data);

             const { auth_token: authToken, redirect_url: redirectUrl } = data;

             if (authToken && 'serviceWorker' in navigator) {
                 console.log('[AUTH.HTML]Processing auth token');
                 
                 try {
                     // Modified Service Worker handling for iOS
                     if (isIOS) {
                         // Store token in localStorage as fallback
                         localStorage.setItem('auth_token', authToken);
                         window.location.replace(redirectUrl);
                         return;
                     }

                     const activeWorker = await initializeServiceWorker();
                     console.log('[AUTH.HTML]Service Worker initialized');

                     await new Promise((resolve, reject) => {
                         const messageChannel = new MessageChannel();
                         const timeoutId = setTimeout(() => {
                             reject(new Error('[AUTH.HTML]Token storage timeout'));
                         }, 5000);

                         messageChannel.port1.onmessage = (event) => {
                             clearTimeout(timeoutId);
                             if (event.data.success) {
                                 resolve();
                             } else {
                                 reject(new Error('[AUTH.HTML]Token storage failed'));
                             }
                         };

                         activeWorker.postMessage({
                             type: 'STORE_AUTH_TOKEN',
                             token: authToken
                         }, [messageChannel.port2]);
                     });

                     window.location.replace(redirectUrl);
                 } catch (error) {
                     console.error('[AUTH.HTML]Service Worker error:', error);
                     // Fallback for iOS
                     localStorage.setItem('auth_token', authToken);
                     window.location.replace(redirectUrl);
                 }
             }
         } catch (error) {
             console.error('[AUTH.HTML]Login error:', error);
             alert('Ein Fehler ist aufgetreten. Bitte versuchen Sie es erneut.');
         }
     });
 }
</script>