<!-- auth.html -->
<script>
(function() {
    window.TokenManager = class TokenManager {
        async getToken() {
            // Try to get token from cookie first
            const cookies = document.cookie.split(';');
            const authCookie = cookies.find(c => c.trim().startsWith('auth_token='));
            if (authCookie) {
                return authCookie.split('=')[1].trim();
            }

            // Fallback: Check localStorage
            const localToken = localStorage.getItem('auth_token');
            if (localToken) {
                // Attempt to restore cookie from localStorage
                document.cookie = `auth_token=${localToken}; max-age=${30*24*60*60}; secure; samesite=Strict`;
                return localToken;
            }

            return null;
        }

        async storeToken(token) {
            // Store in localStorage as backup
            localStorage.setItem('auth_token', token);
        }

        async clearToken() {
            // Clear cookie
            document.cookie = 'auth_token=; expires=Thu, 01 Jan 1970 00:00:00 UTC; path=/; secure; samesite=Strict';
            // Clear backup
            localStorage.removeItem('auth_token');
        }
    }

    console.log('[AUTH.HTML] TokenManager initialized and ready for use');
})();

window.tokenManager = new TokenManager();

(function() {
    // Make auth functions globally available
    window.fetchWithAuth = async function(url, options = {}) {
    try {
        // Cookie will be sent automatically
        const response = await fetch(url, options);

        if (response.status === 401) {
            await tokenManager.clearToken();
            window.location.href = '/login';
            return;
        }

        return response;
    } catch (error) {
        throw error;
    }
};

    // Initialize Axios interceptor
    axios.interceptors.request.use(async (config) => {
        // No need to add Authorization header - cookie is sent automatically
        return config;
    }, (error) => {
        return Promise.reject(error);
    });


    axios.interceptors.response.use(
        async response => {
            const newToken = response.data.new_auth_token;
            if (newToken) {
                await tokenManager.storeToken(newToken);
            }
            return response;
        },
        error => {
            if (error.response?.status === 401) {
                if (error.response?.data?.code === 'PASSWORD_CHANGED') {
                    console.log('[AUTH.HTML] Password changed, clearing all tokens');
                } else {
                    console.log('[AUTH.HTML] Received 401, clearing tokens and redirecting to login');
                }
                
                tokenManager.clearToken();
                window.location.href = '/login';
            }
            return Promise.reject(error);
        }
    );
})();


async function loginUser() {
    const form = document.getElementById('loginForm');
    if (!form) {
        console.log('[AUTH.HTML] Login form not found, exiting loginUser function.');
        return;
    }

    form.addEventListener('submit', async (event) => {
        event.preventDefault();
        console.log('[AUTH.HTML] Form submission prevented, preparing to send login request.');

        const formData = new FormData(form);

        try {
            const response = await fetch('/login', {
                method: 'POST',
                body: formData,
                headers: {
                    'Accept': 'application/json',
                    'X-Requested-With': 'XMLHttpRequest'
                }
            });

            const data = await response.json();
            console.log('[AUTH.HTML] Response received:', data);

            if (!data.success) {
                // Update bus selection if needed
                if (data.buses) {
                    const select = form.querySelector('select[name="walking_bus"]');
                    if (select) {
                        select.innerHTML = data.buses.map(bus =>
                            `<option value="${bus.id}" ${bus.id == data.selected_bus_id ? 'selected' : ''}>${bus.name}</option>`
                        ).join('');
                    }
                }

                // Show error message
                showErrorMessage(form, data.error);
                return;
            }

            // Handle successful login
            const { auth_token: authToken, redirect_url: redirectUrl } = data;

            if (authToken) {
                console.log('[AUTH.HTML] Processing auth token');
                await tokenManager.storeToken(authToken);
                window.location.replace(redirectUrl);
            }
        } catch (error) {
            console.error('[AUTH.HTML] Login error:', error);
            showErrorMessage(form, 'Ein unerwarteter Fehler ist aufgetreten. Bitte versuchen Sie es erneut.');
        }
    });
}


// Helper function for error display
function showErrorMessage(form, message) {
    const errorDiv = document.querySelector('.alert-danger') || 
                    document.createElement('div');
    errorDiv.className = 'alert alert-danger';
    errorDiv.textContent = message;
    
    const formContainer = form.parentNode;
    const existingError = formContainer.querySelector('.alert-danger');
    if (existingError) {
        formContainer.removeChild(existingError);
    }
    formContainer.insertBefore(errorDiv, form);
}

// Add this at the end of the auth.html script section
window.handleLogout = async function() {
    try {
        // Clear localStorage first
        localStorage.clear();
        
        // Call backend logout route
        const response = await fetch('/logout');
        const data = await response.json();
        
        // Unregister all service workers
        if ('serviceWorker' in navigator) {
            const registrations = await navigator.serviceWorker.getRegistrations();
            for (const registration of registrations) {
                await registration.unregister();
            }
        }

        // Delete all caches completely
        if ('caches' in window) {
            const cacheKeys = await caches.keys();
            await Promise.all(
                cacheKeys.map(key => caches.delete(key))
            );
        }

        window.location.href = '/login';
    } catch (error) {
        console.error('[AUTH.HTML][LOGOUT] Error during logout:', error);
        window.location.href = '/login';
    }
}


navigator.serviceWorker.addEventListener('message', async (event) => {
    if (event.data.type === 'AUTH_ERROR' && event.data.status === 401) {
        await tokenManager.clearToken();
        window.location.href = '/login';
    }
});

</script>